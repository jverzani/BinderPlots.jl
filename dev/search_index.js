var documenterSearchIndex = {"docs":
[{"location":"three-d-shapes/#Three-dimensional-shapes","page":"3D shapes","title":"Three dimensional shapes","text":"using BinderPlots\nusing PlotlyDocumenter # hide\n\nversion = BinderPlots.PlotlyLight.plotly.version # hide\nPlotlyDocumenter.change_default_plotly_version(version) # hide\nnothing # hide\n\nnote: Not `Plots` inspired\nThe three dimensional shapes discussed here are developed without paying attention to any Plots.jl interfaces.\n\nMany surfaces are easily described in turns of being the graph of a function fR^2 rightarrow R or in turns of a parameterization F(uv) = langle X(uv) Y(uv) Z(uv) rangle. The surface function readily plots such. However, some surfaces can be more easily described otherwise, and BinderPlots attempts to provide some interface in a few cases.\n\nRather than use the surface type, the following use the mesh3d type which requires a triangularization of the desired surface. Two types of surfaces that are easily triangulated are:\n\n\"star-shaped\" surfaces defined by a boundary, described by xs, ys, zs, and a point p (a vector) with the property that the line segment connecting p to a boundary point does not cross any other boundary point. A simple example is a disc with p being the origin. The triangulation is easy to visualize, the vertices being the origin and adjacent points on the boundary (which is of course discretized by the data).\nThe surface between two space curves defined by selecting n points on each and connecting the points by a line. Paired adjacent points form \"rectangles\" that are easily triangulated.  This is an example of a ruled surface between two space curves. (A star shape is a ruled surface with one of the curves being just a point.)\n\nThe underlying functions have the odd names ★ (i.e., \\bigstar[tab]) and ziptie, along with their ! counterparts.\n\nThese are used to provide the following shapes\n\nparallelogram)q, u, v)! which draws the planar region formed by two vectors u and v anchored at a point q.\ncirc3d!(q, r, n) which draws the disc with origin q, radius r and normal to a vector n\nskirt! which forms a surface defined by an underlying path (either the vector v anchored at q or by values xs, ys, zs) and the paths projection onto the surface of f(x,y)\nband! is an alternative interface, borrowed from Makie, to ziptie!","category":"section"},{"location":"three-d-shapes/#Intersection-of-3-planes","page":"3D shapes","title":"Intersection of 3 planes","text":"The parallelogram function allows planes to easily be described. Contrast the following to an example in the previous section when a plane ax + by = d was described as a parametric surface in order to graph it with surface. Here such planes are described by two orthogonal vectors.\n\nparallelogram( [-1,-1,0], [2,0,0], [0,2,0])\nparallelogram!([-1,0,-1], [0,0,2], [2,0,0])\nparallelogram!([0,-1,-1], [0,2,0], [0,0,2])\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide\n\nThe choice of shapes is done to facilitate certain graphics of calculus.\n\nFor example, to illustrate the method of finding volumes by slices a figure like the following might be of interest:\n\nf(r, u) = 4 - r\nrs = range(0, 4, length=25)\nus = range(0, 2pi, length=25)\nX(r, u) = r * sin(u)\nY(r, u) = r * cos(u)\n\nsurface(X.(rs', us), Y.(rs', us), f.(rs', us), opacity=0.25)\n\nq, n = [0,0,2], [0,0,1]\ncirc3d!(q, 2, n, opacity=0.5, color=\"blue\")\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide\n\nThat utilizes circ3d! to draw a disc with normal vector in the direction of the z axis.\n\nWhereas, this next graphic utilizes skirt! to highlight the intersection of the plane x=-1with surface.\n\nf(x, y) = 1 + cospi(x) + cospi(y)\nxs = ys = range(-1, 1, 100)\n\nsurface(xs, ys, f; opacity=0.25)\n\n# draw skirt between surface and the line p + t*v\np, v = [-1/2,-1,0], [0, 2, 0]\nskirt!(p, v, f; opacity = 0.5, color=:black)\n\n# draw intersection of plane and surface\nr(t) = p + t * v\nts = range(0, 1, length=100)\nxs, ys, _ = BinderPlots.unzip(r.(ts))\nzs = f.(xs, ys)\nplot!(xs, ys, zs, linewidth=10)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide\n\nThe underlying mesh functions can be of use as well.","category":"section"},{"location":"three-d-shapes/#Helix","page":"3D shapes","title":"Helix","text":"The ziptie function lends itself to drawing an helix (or fusili if you are hungry):\n\nr(t) = (sin(t), cos(t), t)\ns(t) = (sin(t+pi), cos(t+pi), t)\nts = range(0, 4pi, length=100)\n\nziptie(BinderPlots.unzip(r.(ts))..., BinderPlots.unzip(s.(ts))...;\n       color=\"green\", opacity=.25, showscale=false)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide\n\nThis is  a related spiraling ribbon using band:\n\nr(t) = (sin(t), cos(t), t)\ns(t) = (sin(t)/2, cos(t)/2, t)\nts = range(0, 4pi, length=100)\n\nband(r.(ts), s.(ts);\n       color=\"seafoam\", opacity=.25, showscale=false)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"section"},{"location":"three-d-shapes/#Star-shapes","page":"3D shapes","title":"Star shapes","text":"This shape is reminiscent of a potato chip, though formed with lines drawn from [0,0,0]:\n\nr(t) = (sin(t), 2cos(t), sin(2t))\nts = range(0, 2pi, 100)\n\n★([0,0,0], BinderPlots.unzip(r.(ts))...)\nplot!(BinderPlots.unzip(r.(ts))..., linewidth=10)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"section"},{"location":"basic-graphics/#Basics-of-BinderPlots","page":"Basics","title":"Basics of BinderPlots","text":"The plotting interface provided by BinderPlots superficially resembles that of Plots.jl. BinderPlots picks some of the many parts of Plots.jl that prove useful for the graphics of calculus and provides a stripped-down, though reminiscent, interface around PlotlyLight, a package which otherwise is configured in a manner very-much like the underlying JavaScript implementation. The Plots package is great – and has a Plotly backend – but for resource-constrained usage can be too demanding.\n\nSome principles of Plots are:\n\nThe Plots.jl interface uses positional arguments for data (with data possibly including reference to some existing figure) and keyword arguments for modifying underlying attributes.\n\nThe BinderPlots.jl interface mostly follows this. However, only some of the Plots.jl keyword arguments are supported. Other keyword arguments are passed directly to Plotly and so should follow the naming conventions therein.\n\nThe PlotlyLight interface is essentially the JavaScript interface for Plotly only with the cleverly convenient Config constructor used to create the nested JavaScript data structures needed through conversion with JSON3. All arguments are like keyword arguments.\n\nIn Plots.jl, every column is a series, a set of related points which form lines, surfaces, or other plotting primitives.\n\nPlotly refers to series as traces. This style is mostly supported in BinderPlots. Using multiple layers is suggested, but matrices can be used to specify multiple series.\n\nIn Plots.jl for keyword arguments many aliases are used, allowing for shorter calling patterns for experienced users.\n\nMany, but not all, of the aliases are available. (The shorter ones are not, as they seem as cryptic as magic arguments and more work to type.)\n\nIn Plots.jl some arguments encompass magic arguments for setting many related arguments at the same time.\n\nBinderPlots allows for magic arguments.\n\nIn Plots.jl the available plot types are specified through seriestype and there are shorthands to produce different methods (e.g., scatter is a shorthand for the seriestype :scatter.\n\nThis is only partially the case with BinderPlots, as not all plot types have a shorthand defined.\n\nAltogether, most basic graphics created through Plots can be produced with BinderPlots, but of the showcase of 66 examples, which utilize many corners of the Plots.jl interface, only about 23 are fully runnable.","category":"section"},{"location":"basic-graphics/#Supported-plotting-functions","page":"Basics","title":"Supported plotting functions","text":"We load the package in the typical manner:\n\nusing BinderPlots\nusing PlotlyDocumenter # hide\n\nThis package directly implements some of the Plots recipes for functions that lessen the need to manipulate data.","category":"section"},{"location":"basic-graphics/#plot(f,-a,-b)","page":"Basics","title":"plot(f, a, b)","text":"The plot function from PlotlyLight is given several methods through dispatch to create line graphs.\n\nThe simplest means to plot a function f over the interval [a,b] is through the declarative pattern plot(f, a, b). For example:\n\nplot(sin, 0, 2pi)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide\n\nThe sin object refers to a the underlying function to compute sine. More commonly, the function is user-defined as f, or some such, and that function object is plotted.\n\nThe interval may be specified using two numbers or with a container, in which case the limits come from calling a method of extrema for Plot objects. A default of (-55) is used when no interval is specified.\n\nFor line plots, as created by this usage, the supported key words include\n\nlinecolor to specify the color of the line; linealpha for the transparency\nlinewidth to adjust width in pixels\nlinestyle to adjust how line is drawn\nlineshape to adjust how the line is interpolated between adjacent points\nlabel can be used to name the entry for given trace, unless legend=false has been specified\n\nnote: Note\nAll plotting functions in BinderPlots return an instance of PlotlyLight.Plot. These objects can be directly modified and re-displayed. The show method creates the graphic for viewing. The current function returns the last newly created plot.","category":"section"},{"location":"basic-graphics/#plot(xs,-ys,-[zs])-or-plot(pts)","page":"Basics","title":"plot(xs, ys, [zs]) or plot(pts)","text":"The points to plot may be specified directly.\n\nPoints can be given as (x_1 y_1) (x_2y_2) dots (x_n y_n) or as two vectors (x_1 x_2 dots x_n) and (y_1 y_2 dots y_n). When the latter, they must be of equal length, as internally they are paired off.\n\nFor example, we might bypass the automatic selection of points to plot and create these directly:\n\nxs = range(0, pi, length=251)\nf(x) = sin(sin(x^2))\nys = f.(xs)\nplot(xs, ys)\n\ng(x) = (x, sin(sin(x^3)))\nplot!(g.(xs))\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide\n\nAt times it is more convenient to generate pairs of points. In the above example, g returns (xy) pairs. Tuples and other non-vector containers of points can be plotted directly, as just shown.\n\nThe plot(xs, ys) function simply connects the points (x_1y_1) (x_2y_2) dots  sequentially with lines in a dot-to-dot manner (the lineshape argument can modify this). If values in y are non finite, then a break in the dot-to-dot graph is made.\n\nUse plot(xs, ys, zs) for line plots in 3 dimensions, which is illustrated in a different section.\n\nIf one or more x or y (or z) is a matrix, then each column will be treated as specifying a trace. In this case, most keyword arguments will be cycled over including the magic arguments. For example:\n\nm, n = 10, 3\nx = 1:m\ny = rand(m, n)\nplot(x, y; label=(\"one\",\"two\",\"three\"), linecolor=(:red, :green, :blue))\n\nto_documenter(current())           # hide\n\nnote: Note\nIt is a bit subtle, but a vector of vectors is treated as holding multiple series; whereas a vector of tuples (or other containers) is treated as a collection of points.","category":"section"},{"location":"basic-graphics/#plot!","page":"Basics","title":"plot!","text":"Layers can be added to a figure created by plot. The notation follows Plots.jl and uses Julia's convention of indicating functions which mutate their arguments with a !. The underlying plot is mutated (by adding a layer) and reference to this may or may not be in the plot! call. (When missing, the current plotting figure, determined by current(), is used.)\n\nplot(sin, 0, 2pi)\n\nplot!(cos)    # no limits needed, as they are computed from the current figure\n\nplot!(x -> x, 0, pi/2)      # limits can be specified\nplot!(x -> 1 - x^2/2, 0, pi/2)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"section"},{"location":"basic-graphics/#plot([f,g,...],-a,-b)","page":"Basics","title":"plot([f,g,...], a, b)","text":"As a convenience, to plot two or more traces in a graphic, a vector of functions can be passed in. In which case, each is plotted over the interval. (Similar to using plot to plot the first and plot! to add the rest.)","category":"section"},{"location":"basic-graphics/#plot(fs::NTuple{N,Function},-a,-b)","page":"Basics","title":"plot(fs::NTuple{N,Function}, a, b)","text":"Two dimensional parametric plots show the trace of (f(t) g(t)) for t in ab. These are easily created by plot(x,y) where the x and y values are produced by broadcasting, say, such as f.(ts) where ts = range(a,b,n).\n\nnote: Not encouraged\nThe Plots.jl convenience signature is plot(f::Function, g::Function, a, b). This is supported but with a warning indicating it is best to pass a tuple of functions, as in plot((f,g), a, b).","category":"section"},{"location":"basic-graphics/#plot(::Array{:Plot,N})-or-plot(::Plot...)","page":"Basics","title":"plot(::Array{<:Plot,N}) or plot(::Plot...)","text":"Arrange an array of plot objects into a regular layout for display.\n\n(Plots.jl uses a different convention.)","category":"section"},{"location":"basic-graphics/#plot(;-seriestype::Symbol,-kwargs...)","page":"Basics","title":"plot(; seriestype::Symbol, kwargs...)","text":"The seriestype argument resolves to a plotly type and possibly mode which could be specified directly to PlotlyLight. For example, plot(x, y; type=\"scatter\", mode=\"markers+lines\", ...) would produce a scatter plot along with lines connecting the points. This task can be done by either combining  plot with scatter! (introduced next) or passing seriestype=[:lines, :scatter].\n\nFor many basic graphics, there are shorthands, such as scatter! to initiate the plotting, as opposed to specifying a seriestype value. For the basic graphics of statistics, they use of the series type is necessary, as no shorthands are provided.","category":"section"},{"location":"basic-graphics/#scatter(xs,-ys,-[zs])-or-scatter(pts)","page":"Basics","title":"scatter(xs, ys, [zs]) or scatter(pts)","text":"Save for a few methods, the plot method represents the data with type line which instructs Plotly to connect points with lines.\n\nRelated to plot and plot! are scatter and scatter!; which render just the points, without connecting the dots.\n\nThe following Plots.jl marker attributes are supported:\n\nmarkercolor to adjust the color; markeralpha for its transparency level\nmarkersize to set the marker size\nmarkershape to set the shape\n\nA \"magic\" specification like marker=(:diamond, 20, :blue, 0.75) will set the four attributes above with matching by type. (The set of marker shapes is extensive, but this package does not allow the aliases used by Plots.jl. E.g., :d for :diamond or :hex for :hexagon.)","category":"section"},{"location":"basic-graphics/#Text-and-arrows","page":"Basics","title":"Text and arrows","text":"The annotate!, quiver!, arrow and arrow! functions are used to add text and/or arrows to a graphic.\n\nThe annotate! function takes a a tuple of (x,y,txt) points or vectors of each and places text at the x-y coordinate. Text attributes can be adjusted.\n\nThe quiver! function plots arrows with optional text labels. Due to the underlying use of Plotly, quiver is restricted to 2 dimensions. The arguments to quiver are tail position(s) in x and y and arrow lengths, passed to quiver as dx and dy. The optional txt argument can be used to label the anchors.\n\nThe BinderPlots.arrow! function is not from Plots.jl. It provides a different interface to arrow drawing than quiver. For BinderPlots.arrow! the tail and vectors are passed in as vectors. (so for a single arrow from p=[1,2] with direction v=[3,1] one call would be arrow!(p, v) (as compared with quiver([1],[2], quiver=([3],[1]))). The quiver style is more efficient for many arrows.\n\nThe BinderPlots.arrows! function borrows the Makie.jl interface to specify an arrow (basically arrows!(x,y,u,v) is quiver!(x,y,quiver=(u,v)).\n\nThe following Plots.jl text attributes are supported:\n\ncolor\nfamily\npointsize\nrotation\n\nFor labels and annotations, the call text(str, args...) can be used to specify font properties. For example text(\"label\", :red, 20) specifies the color and text size for the string when used to label a graphic. The font function takes the args... and returns a Font object, which allow various text attributes to be customized.","category":"section"},{"location":"basic-graphics/#Shapes","page":"Basics","title":"Shapes","text":"The Shape constructor can be used to specify a polygon, as with Shape(xs, ys). There are a few built-in shapes available by specifying a symbol (e.g. Shape(:diamond) or Shape(:unitsquare).\n\nThese Shape instances can be manipulated by translate, rotate, scale, shear, and their mutating versions. As well there is invert! and center!.\n\nThese need to be qualified, or can be imported with this command:\n\nimport BinderPlots: translate, translate!, rotate, rotate!, scale, scale!, shear, shear!, invert!, center!\n\nThe following create regions which can be filled.  Shapes have an interior and exterior boundary.\n\nThe following Plots.jl fill attributes are supported:\n\nfillcolor a color, use rgb to specify a color with alpha level, e.g. rgb(:green, 0.25) (this is like Plots.plot_color, but more general as rgb also takes RGB values in the range 0 to 225.\nfillrange one of :none, :tozerox, :tonextx, :tozeroy (or 0), :tonexty, :toself, :tonext. The default for Shape instances is :toself.\n\nUse stroke to specify attributes for the enclosing polygonal line. The stroke function matches by type: strings and symbols are matched to the lines styles, if no match a color is assumed; values in (0,1) are identified as transparency levels,  integers are identified as line widths.\n\nnote: Note\nUnlike Plots.jl Shape instances can not be used directly as marker shapes.\n\nOther plotting commands that create 2d-regions are:\n\nrect!(x0, x1, y0, y1) draws a rectangle between (x0, y0) and (x1, y1).\nhspan!(ys, YS; xmin=0.0, xmax=1.0) draws horizontal rectangle(s) with bottom and top vertices specified by ys and YS. (A different calling style than Plots.jl.)\nvspan!(xs, XS; ymin=0.0, ymax=1.0) draws vertical rectangle(s) with left and right vertices specified by xs and XS.\ncircle!(x0, x1, y0, y1) draws a \"circular\" shape in the rectangle given by (x0, y0) and (x1, y1).\npoly!(points; kwargs...) where points is a container of (xy) or (xyz) coordinates. Alternate to Shape.\nband!(lower, upper, args...; kwargs...) draws a ribbon or band between lower and upper. These are either containers of (x,y) points or functions, in which case args... is read as a, b, n = 251 to specify a range of values to plot over. The function can be scalar valued or parameterizations of a space curve in 2 or 3 dimensions. The ribbon argument of Plots is not supported.\n\nThe series type :ribbon is used to draw a band around a function. The band is defined by the ribbon argument.\n\nThere are just mutating versions of the above.\n\nIn addition, there are a few, simple, non-polygonal shapes, including lines:\n\nhline!(y; xmin=0.0, xmax=1.0) draws a horizontal line at elevation y across the computed axis, or adjusted via xmin and xmax.  The extrema function computes the axis sizes. If y is a container, multiple lines are drawn.\nvline(x; ymin=0.0, ymax=1.0)  draws a vertical line at  x across the computed axis, or adjusted via ymin and ymax. The extrema function computes the axis sizes. If x is a container, multiple lines are drawn.\nabline!(intercept, slope) for drawing lines a + bx in the current frame.\n\nThere are also Shape(:hline) and Shape(:vline) that can be used, though typically would require some translation and scaling. These are used by the series types :xerror and :yerror for creating error bars; see below.\n\n\n\nFor example, this shows how one could visualize the points chosen in a plot, showcasing both plot and scatter! in addition to a few other plotting commands:\n\nf(x) = x^2 * (108 - 2x^2)/4x\nx, y = BinderPlots.unzip(f, 0, sqrt(108/2))\nplot(x, y; legend=false)\nscatter!(x, y, markersize=10) #  or plot(f, 0, sqrt(108/2); seriestype=(:lines, :scatter), legend=false, markersize=10)\n\nquiver!([2,4.3,6],[10,50,10], [\"sparse\",\"concentrated\",\"sparse\"],\n        quiver=([-1,0,1/2],[10,15,5]))\n\n# add rectangles to emphasize plot regions\ny0, y1 = extrema(current()).y  # get extent in `y` direction\nrect!(0, 2.5, y0, y1, fillcolor=\"#d3d3d3\", fillalpha=0.2)\nrect!(2.5, 6, y0, y1, linecolor=\"black\", fill=(\"orange\", 0.2))\nx1 = last(x)\nrect!(6, x1, y0, y1, fillcolor=rgb(150,150,150), opacity=0.2)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide\n\nThe values returned by BinderPlots.unzip(f, a, b) are not uniformly chosen, rather where there is more curvature there is more sampling. For illustration purposes, this is emphasized in a few ways: using quiver! to add labeled arrows and rect! to add rectangular shapes with transparent filling.\n\nAs seen in this overblown example, there are other methods besides plot for other useful tasks. These include:\n\nscatter! is used to plot points using markers.\nquiver! is used to add arrows to a plot. These can optionally have their tails labeled, so this method can be repurposed to add annotations.  The quiver command allows for text rotation. Also arrow and arrows for different interfaces for drawing arrows. The annotate! function is used to add annotations at a given point. There are keyword arguments to adjust the text size, color, font-family, etc.\nrect! is used to make a rectangle. There are also hspan! and vspan!. For lines, there are hline! and vline! to draw horizontal or vertical lines across the extent of the plotting region. There is also abline! to draw lines specified in intercept-slope form across the extent of the plotting region. Other regions can be drawn. For example, circle! to draw a circle, and, more generally, poly can be used to draw a polygonal region, though Shape would be suggested.\n\nFor another example, shapes can be used to create error bars. For example, suppose at a pair of points, error bars with width sigma are to be drawn:\n\nimport BinderPlots: translate, scale\nxs = 1:5\nys = [1,3,2,4,5]\nsigmas = 1 ./ (1:5)\n\nscatter(xs, ys, markersize=5)\n\nvl = Shape(:vline)\nerrors = [translate(scale(vl, 1, σ), x, y) for (σ, x,y) in zip(sigmas, xs, ys)]\nplot!(errors; fill=(stroke(2),) )\n\nto_documenter(current())           # hide\n\nTo adjust the width of the bar, we pass the value through stroke. Error bars can be added with the series type :xerror, as with plot!(xs, ys; seriestype=[:xerror], xerror=(1 ./ (1:5), )).","category":"section"},{"location":"basic-graphics/#Attributes","page":"Basics","title":"Attributes","text":"Attributes of a plot or its series are modified through keyword arguments. The Plots.jl interface allows many aliases and has magic arguments to ease this specification. No attempt to cover all of these conveniences is made.","category":"section"},{"location":"basic-graphics/#Keyword-arguments","page":"Basics","title":"Keyword arguments","text":"The are several keyword arguments used to adjust the defaults for the graphic, for example, legend=false and markersize=10. Some keyword names utilize Plots.jl naming conventions and are translated back to their Plotly counterparts. Additional keywords are passed as is, so should use the Plotly names.\n\nSome keywords chosen to mirror Plots.jl are:\n\nArgument Used by Notes\nsize=(width=..., height=...) new plot calls set figure size, cf. size! with named tuple; alias windowsize\nxlims, ylims new plot calls set figure boundaries, cf xlims!, ylims!, extrema\nlegend new plot calls set or disable legend\naspect_ratio new plot calls set to :equal for equal x-y (and z) axes\nlabel plot, plot! set with a name for trace in legend\nlinecolor plot, plot! set with a color; alias lc\nlinealpha plot, plot! set with a value in (0,1)\nlinewidth plot, plot! set with an integer; aliases lw, width\nlinestyle plot, plot! set with \"solid\", \"dot\", \"dash\", \"dotdash\", ...; aliases style, ls\nlineshape plot, plot! set with \"linear\", \"hv\", \"vh\", \"hvh\", \"vhv\", \"spline\"; from plotly\nline plot, plot! set with tuple of magic line arguments\nmarkershape scatter, scatter! set with \"diamond\", \"circle\", ...; alias shape\nmarkersize scatter, scatter! set with integer; alias ms\nmarkercolor scatter, scatter! set with color; alias mc\nmarkeralpha scatter, scatter! set with a value in (0,1)\nmarker scatter, scatter! set with tuple of magic marker arguments\nfillcolor shapes interior color of a 2D shape; alias fc\nfillalpha shapes set with a value in (0,1)\nfillrange shapes how much to fill\nfill shapes set with magic fill arguments\ncolor annotate! set with color argument of text\nfamily annotate! set with string (font family)\npointsize annotate! set with integer\nrotation annotate! set with angle, degrees, real\ncenter new 3d plots set with tuple, see controls\nup new 3d plots set with tuple, see controls\neye new 3d plots set with tuple, see controls\n\nAs seen in the example there are many ways to specify a color. These can be by name (as a symbol or as a string),  using HEX colors (as strings), using rgb. (The rgb function, unlike the standard Colors.RGB, uses values in 0 to 255 to specify the values and also can take a fourth argument for an alpha value, which is useful for filling with opacity.)\n\nSome exported names are used to adjust a plot after construction:\n\ntitle!, xlabel!, ylabel!, zlabel!: to adjust title; x-axis label; y-axis label\nxlims!, ylims!, zlims!: to adjust limits of viewing window\nxticks!, yticks!, zticks!: to adjust axis ticks\nxaxis!, yaxis!, zaxis!: to adjust the axis properties\n\nnote: Subject to change\nThere are some names for keyword arguments that should be changed.","category":"section"},{"location":"basic-graphics/#\"Magic\"-arguments","page":"Basics","title":"\"Magic\" arguments","text":"The designer of Plots.jl cleverly recognized that many argument types come in similar groups. For example, lines, markers, and filling all have a color and an alpha transparency level. Each may have a different style or shape. Each may have a different scale. Moreover, scales are described by integers, styles described by symbols or strings, colors by symbols or strings – if not a more specific type –  and transparencies by a number in (01). As Julia can readily dispatch on value types, an expression like (:red, 0.25, 12) can be  parsed to identify a color, an alpha level and a scale. From here, it was a smart move to use keywords, like line and fill, to associate these values with different attribute groups.\n\nThe Plots.jl design leverages data types to \"magically\" fill in keyword arguments. Much of this is implemented within BinderPlots, as described next.","category":"section"},{"location":"basic-graphics/#Series-arguments","page":"Basics","title":"Series arguments","text":"The special keyword arguments line, marker, and fill are iterated over to fill in keyword arguments. For example, passing line=(5, (:red, :blue), 0.25, :dash) will specify: Draw all lines with width 5, linealpha=0.25, and use dashes, not solid lines, for the line style. For any odd number series the line color will be rgb(:red, 0.25); even numbered series (when present) will have color rgb(:blue, 0.25), as the values passed to line are recycled when there are multiple series specified.\n\nThe container passed to line has the following mappings:\n\nsymbols and strings are matched against the possible linestyles, then the possible lineshapes; if there is no match, then the value is assumed to specify a color\na number in (0,1) indicates a transparency level\nan integer specifies the scale for the line width\nrgb values are passed to the linecolor attribute (as are the widely used RGB values from PlotUtils)\na Stroke object, produced by stroke, can alternatively be used to specify these values\n\nThe container passed to marker has the following mappings:\n\nsymbols and strings are matched against known marker shapes; if there is no match then the value is assumed to specify a color\nscale, color, and transparency are as for line\n\nThe container passed to fill has the following mappings:\n\nsymbols and strings are matched against fill styles; if there is no match then the value is assumed to specify a color\na number in (0,1) indicates a transparency level\na 0 sets fill style = :tozeroy. (Other integers are not available, as in Plots.jl)\na true indicates the fill style should be :toself\nStroke objects, produced by stroke, adjust the properties of the line","category":"section"},{"location":"basic-graphics/#Other-uses-of-magic-arguments","page":"Basics","title":"Other uses of magic arguments","text":"The font function (which can be called directly or indirectly through text or annotate!) has the following magic arguments defined:\n\nstrings are assumed to indicate font families\nsymbols are checked for alignment (e.g., :top, :bottom, etc.); if no match, they are assumed to be a color specification.\nintegers specify point sizes\nnon integers (e.g. pi/4) indicate rotation\n\nThe legend argument can be a Boolean or a container. When a container the values are magically transformed with:\n\nsymbols are checked for correspondence with a legend position; if the symbol is :reverse, otherwise the symbol is assumed to be a color specification.\ntuples indicate the placement position\nFont instances, as produced by font, indicate the font in the legend\nBoolean values indicate whether to show or hide the legend\n\nThe [xyz]axis! function arguments have:\n\nSymbols are checked for scale indicators (:log, :linear, :log2m :log10, :flip, :invert, :inverted)\nstrings and Text values are applied to the axis label.\ntuples are assumed to indicate a range if length 2, otherwise a collection of tick placements.\nFont values apply to the tick fonts\nBoolean values indicate if the grid should be shown for that axis","category":"section"},{"location":"basic-graphics/#Example","page":"Basics","title":"Example","text":"This example is from the section on \"Input Data\" from the Plots.jl documentation. It use shapes and other objects to draw a Batman scene. We recreate it here to illustrate some small but significant differences between Plots.jl and BinderPlots. The comments with superscripts are where differences are needed:\n\nusing BinderPlots\nimport BinderPlots: translate, stroke, BezierCurve #¹\n\nconst Plots = BinderPlots\nRGB(a,b,c) = rgb(round.(Int, 255 .* (a,b,c))...) #²\nconst plot_color = rgb\n\nfunction make_batman()\n    p = [(0, 0), (0.5, 0.2), (1, 0), (1, 2),  (0.3, 1.2), (0.2, 2), (0, 1.7)]\n    s = [(0.2, 1), (0.4, 1), (2, 0), (0.5, -0.6), (0, 0), (0, -0.15)]\n    m = [(p[i] .+ p[i + 1]) ./ 2 .+ s[i] for i in 1:length(p) - 1]\n\n    pts = similar(m, 0)\n    for (i, mi) in enumerate(m)\n        append!(\n            pts,\n            map(BezierCurve([p[i], m[i], p[i + 1]]), range(0, 1, length = 30))\n        )\n    end\n    x, y = Plots.unzip(Tuple.(pts))\n    Shape(vcat(x, -reverse(x)), vcat(y, reverse(y)))\nend\n\n# background and limits\nplt = plot(\n    bg = :black,\n    xlim = (0.1, 0.9),\n    ylim = (0.2, 1.5),\n    framestyle = :none,\n    size = (400, 400),\n    legend = false,\n)\n\nxaxis!(plt; showticklabels = false, showgrid = false, zeroline = false) #³\nyaxis!(plt; showticklabels = false, showgrid = false, zeroline = false) #³\n\n\n\n# create an ellipse in the sky\npts = Plots.partialcircle(0, 2π, 100, 0.1)\nx, y = Plots.unzip(pts)\nx = 1.5x .+ 0.7\ny .+= 1.3\npts = collect(zip(x, y))\n\n# beam\nbeam = Shape([(0.3, 0.0), pts[95], pts[50], (0.3, 0.0)])\nplot!(beam, fillcolor = plot_color(:yellow, 0.3))\n\n# spotlight\n# plot!(Shape(x, y), c = :yellow)  #⁴ no seriescolor argument\nplot!(Shape(x, y), fc = :yellow)\n\n# buildings\nrect(w, h, x, y) = Shape(x .+ [0, w, w, 0, 0], y .+ [0, 0, h, h, 0])\ngray(pct) = RGB(pct, pct, pct)\nfunction windowrange(dim, denom)\n    range(0, 1, length = max(3, round(Int, dim/denom)))[2:end - 1]\nend\n\nfor k in 1:50\n    local w, h, x, y = 0.1rand() + 0.05, 0.8rand() + 0.3, rand(), 0.0\n    shape = rect(w, h, x, y)\n    graypct = 0.3rand() + 0.3\n    plot!(shape, fc = gray(graypct))  #⁴\n\n    # windows\n    I = windowrange(w, 0.015)\n    J = windowrange(h, 0.04)\n    local pts = vec([(Float64(x + w * i), Float64(y + h * j)) for i in I, j in J])\n\n    windowcolors = Symbol[rand() < 0.2 ? :yellow : :black for i in 1:length(pts)]\n    local xs, ys = BinderPlots.unzip(pts)\n    scatter!(xs', ys', marker = (stroke(0), :square, windowcolors)) #⁵\n\n\nend\nplt\n\nbatman = Plots.scale(make_batman(), 0.07, 0.07, (0, 0))\nbatman = translate(batman, 0.7, 1.23)\nplot!(batman, fillcolor = :black)\n\nto_documenter(current())           # hide\n\nTo remark on the differences:\n\nThe translate and scale methods for Shape instances and the BezierCurve constructor (lifted directly for Plots.jl) are not exported.\nthe use of RGB from Colors.jl is not supported in PlotlyLight and hence BinderPlots. The rgb function is a replacement which also replaces the plot_color function used above to add an alpha transparency to a color specified by a symbol. (For magic arguments, RGB values are converted to rgb instances.)\nThe illustrated use of xaxis! and yaxis! is needed to make a blank canvas. There is also an unexported blank_canvas function to avoid this detail.\nThere is no support for the seriescolor argument (with the c alias). Rather the fill color is needed to be specified in this line.\nThe Plots.jl interface allows individual points in a scatter plot to have colors specified, so scatter!(pts, ...) works, where the values specified to marker are recycled. However, this is not the case with\n\nthe BinderPlots interface which specifies these colors at the series level. In the above, taking the adjoint of the x- and y-values creates an abstract matrix, and then each column is taken as specifying a different series. Alternatively, two series could be used to paint the windows black or yellow. For example:\n\ninds = [rand() < 0.2 for i in 1:length(pts)]\nscatter!(BinderPlots.Series(pts[inds], pts[.!inds]), marker=(stroke(0), :square, (:yellow,:black)))\n\nAlso, the shape :square is used, not :rect, as in the original, for this is not a supported shape in Plotly.","category":"section"},{"location":"basic-graphics/#Currently-unsupported","page":"Basics","title":"Currently unsupported","text":"The last example highlighted a few differences between Plots.jl and less featureful BinderPlots.jl. In addition to a less relaxed method for data specification, a few other important differences are summarized in the following (with order given by failing examples from the examples.jl file):\n\nSome markers are not supported, and if passed as a magic argument will be identified as a color (e.g., :hex,:d, :rect, ...)\nSeveral shorthands are not defined (e.g. histogram, histogram2d, bar, OHLC, pie, boxplot, violin, spy, portfoliocomposition, areaplot, curves)\n\nx The seriestype might be defined. If not, defining a method for SeriesType, like BinderPlots.SeriesType(::Val{:histogram2d}) = (:histogram2d, :histogram2d) where the return lists a type and a mode value for plotly, may work.\n\nThe @layout macro is not supported\n\nThe only grid layout is to put the plots into an array, one plot per cell. For side-by-side plots, plot(p1, p2, ...) is supported.\n\nA PR would be most welcome.\n\nShapes cannot be used as custom markers\n\nPlots.jl allows custom shapes as markers. This is not supported, though can be mimicked, as in the following:\n\ns = Shape(:star6)\nBinderPlots.scale!(s, 1/20) # shape is roughly unit circle size\nxs, ys = rand(50), rand(50)\n\nBinderPlots.blank_canvas(xlims=(0,1), ylims=(0,1),\n    aspect_ratio=:equal)\nplot!([BinderPlots.translate(s, x, y) for (x,y) in zip(xs,ys)],\n             fill=(:yellow, clamp.(rand(50), 0.5, 1), BinderPlots.stroke(:black)),\n\t\t\t bg=:black)\n\n\nto_documenter(current())           # hide\n\nThere is no @df macro\nThe projection keyword is not supported for polar maps\nPlotsMeasures are not supported\nAnimations are not supported\nmagic grid arguments are not supported\nThe ribbon argument is not supported in the same manner\n\nRibbons must be specified with the seriestype :ribbon. The band function may be a substitute.\n\nThe lens feature is not supported\nThe default function is not supported\nlinked axes are not supported\nMesh3d support is lacking\nseriestype is slightly different\n\nIn Plots.jl it can modify how a line is drawn, use linestyle for that instead.\n\nguides are not supported\nflipping of axes is note supported\nhspan! and vspan! have different calling styles; there are no hspan or vspan methods\nThere are no annotations at discrete locations, only at points\nproj_type is not supported; camera is idiosyncratic\nBezier curves are a bit more cumbersome than calling curves\n\nThe curves function might be replicated by:\n\nfunction curves(x, y; kwargs...)\n   BC = BinderPlots.BezierCurve(tuple.(x,y))\n   plot(t -> BC(t), 0, 1; kwargs...)\n   scatter!(BC.control_points, marker=(12, 0.75))\nend\ncurves(1:4, [1,1,2,4]; title=\"Bezier Curve\")\n\nto_documenter(current())           # hide\n\nThere is no hatching for fill style\nShared axes (twinx) are not supported\nlegend positioning is different","category":"section"},{"location":"reference/#BinderPlots.BinderPlots","page":"Reference/API","title":"BinderPlots.BinderPlots","text":"BinderPlots is a lightweight interface to the underlying PlotlyLight package (Fastest time-to-first-plot in Julia!), itself an \"ultra-lightweight interface\" to the Plotly javascript libraries. BinderPlots supports some of the Plots.jl interface for plotting. This package may be of use as an alternative to Plots in resource-constrained environments, such as binder.\n\nPlots.jl uses\n\npositional arguments for data\nkeyword arguments for attributes\nplot() is a workhorse with seriestype indicating which plot; there are also special methods (e.g. scatter(x,y) becomes plot(x,y; seriestype=\"scatter\"))\n\nPlotlyLight.jl uses\n\ndata::Vector{Config} to hold tracts of data for plotting\nlayout::Config to adjust layout\nconfig::Config to adjust global configurations\nConfig very flexibly creates the underlying Javascript objects the plotly interface expects\nPlot() is a workhorse with type acting like seriestype and also mode\n\nBinderPlots.jl has this dispatch for plot:\n\nLine plot. connecting x,y (and possibly z). For 2D, use !isfinite values in y to break.\n\nplot(x,y,[z]; kwargs...)\nplot!([p::Plot], x, y, [z]; kwargs...)\nplot(pts; kwargs...)\nplot!([p::Plot], pts; kwargs...)\n\nData can be generated from a function:\n\nplot(f::Function, ab; kwargs...) => plot(unzip(f, ab)...; kwargs...)\nplot(f::Function, a, b; kwargs...) => plot(unzip(f, a, b)...; kwargs...)\nplot!([p::Plot], f, ab, [b])\n\nplot each function as lineplot:\n\nplot(fs::Vector{Function}, a, [b]; kwargs...)\nplot!([p::Plot], fs::Vector{Function}, a, [b]; kwargs...)\n\nnote: Note\nCurrently x, y make vectors; should matrices be supported using column vectors? \"In Plots.jl, every column is a series, a set of related points which form lines, surfaces, or other plotting primitives. \"\n\nParametric line plots, 2 or 3d\n\nplot(fs::NTuple(N,Function), a, [b]; kwargs...)\nplot!([p::Plot], fs::NTuple(N,Function), a, [b]; kwargs...)\n\nAlternatively\n\nplot(u::Function, v::Function, [w::Function], a, [b]; kwargs...)\n\nThe plot interface of PlotlyLight: merge layout; merge config; pass kwargs to Config push onto data or merge onto last tract:\n\nplot(; layout::Config?, config::Config, kwargs...)\nplot!([p::Plot]; layout::Config?, config::Config?, kwargs...)\n\nThis interface can be used to generate other plot types either by specifying the type argument, or using the form plot.plot_type(...), as with plot.scatter(x, y).\n\nThe plot function primarily plots line plots where the specified points are connected with lines (when finite); The scatter function plots just the points.\n\nIn addition there are these plot constructors for higher-dimensional plots\n\ncontour\nplot_implicit\nheatmap\nsurface\nwireframe\n\nThere are also numerous functions to modify attributes of an existing plot.\n\n\n\n\n\n","category":"module"},{"location":"reference/#BinderPlots.BezierCurve","page":"Reference/API","title":"BinderPlots.BezierCurve","text":"create a BezierCurve for plotting\n\nFrom Plots.jl\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinderPlots.Series","page":"Reference/API","title":"BinderPlots.Series","text":"Series(xs₁, xs₂, …)\n\nStruct to indicate traces in a series. Can be used in place of matrix to combine mismatched sizes, e.g.\n\nscatter(BinderPlots.Series(1:3, 1:5), markersize=(20,10))\n\nNot exported.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinderPlots.Shape","page":"Reference/API","title":"BinderPlots.Shape","text":"Shape(x, y)\nShape(vertices)\n\nConstruct a polygon to be plotted.\n\nWhen plotting shapes, use stroke argument to fill to adjust bounding line properties.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinderPlots.SeriesType-Tuple{Symbol}","page":"Reference/API","title":"BinderPlots.SeriesType","text":"SeriesType(x::Symbol)\n\nReturn a type and mode for plotly based on a Plots.jl series type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.abline!-Tuple{Any, Any}","page":"Reference/API","title":"BinderPlots.abline!","text":"abline!([p::Plot], intercept, slope; kwargs...)\n\nDraw line y = a + bx over current viewing window, as determined by extrema(p).\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.annotate!-Tuple{Plot, Any, Any, Any}","page":"Reference/API","title":"BinderPlots.annotate!","text":"annotate!([p::Plot], x, y, txt; [color], [family], [pointsize], [halign], [valign])\nannotate!([p::Plot], anns::Tuple;  kwargs...)\n\nAdd annotations to plot.\n\nx, y, txt: text to add at (x,y)\ncolor: text color\nfamily: font family\npointsize: text size\nhalign: one of \"top\", \"bottom\"\nvalign: one of \"left\", \"right\"\nrotation: angle to rotate\n\nThe x, y, txt values can be specified as 3 iterables or tuple of tuples.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.arrow-Tuple{Any, Any}","page":"Reference/API","title":"BinderPlots.arrow","text":"arrow(tails, vs; kwargs...)\n\nDraw vectors vs anchored at tails. Hacked in support for 3D using combination of lines + cones.\n\nUse Plotly attributes arrowcolor, arrowwidth,\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.arrows-Tuple{Any, Any, Function}","page":"Reference/API","title":"BinderPlots.arrows","text":"arrows(x, y, [z], f::Function; kwargs...)\narrows(x, y, [z], u, v, [w]; kwargs...)\narrows!([p::Plot], x, y, [z], f::Function; kwargs...)\narrows!([p::Plot], x, y, [z], u, v, [w]; kwargs...)\n\nDraw arrows from x-y-[z] with lengths u-v-w (or optionally generated by f).\n\nExample\n\nplot(;xlims=(-5,5), ylims=(-5,5))\nf(x,y) = (-y,x)./sqrt(1 + x^2 + y^2)\ngrid = tuple.((-5:5)', (-5:5))\narrows!(unzip(grid)..., f)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.band-Tuple{Any, Any, Vararg{Any}}","page":"Reference/API","title":"BinderPlots.band","text":"band(lower, upper; kwargs...)\nband(lower::Function, upper::Function, a::Real, b::Real,n=251; kwargs...)\nband!([p::Plot],lower, upper; kwargs...)\nband!([p::Plot],lower::Function, upper::Function, a::Real, b::Real,n=251; kwargs...)\n\nDraw band between lower and upper. These may be specified by functions or by tuples of x-y-[z] values.\n\nExample\n\nUsing (x,y) points to define the boundaries\n\nxs = 1:0.2:10\nys_low = -0.2 .* sin.(xs) .- 0.25\nys_high = 0.2 .* sin.(xs) .+ 0.25\n\np = plot(;xlims=(0,10), ylims=(-1.5, .5), legend=false)\nband!(zip(xs, ys_low), zip(xs, ys_high); fillcolor=:blue)\nband!(zip(xs, ys_low .- 1), zip(xs, ys_high .- 1); fillcolor=:red)\n\nOr, using functions to define the boundaries\n\nband(x -> -0.2 * sin(x) - 0.25, x -> 0.2 * sin(x) + 0.25,\n     0, 10;  # a, b, n=251\n     fillcolor=:red, legend=false)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.center-Tuple{Shape}","page":"Reference/API","title":"BinderPlots.center","text":"return the centroid of a Shape\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.circ3d-Tuple{Any, Any, Any}","page":"Reference/API","title":"BinderPlots.circ3d","text":"circ3d(q, r, n̄; kwargs...)\ncirc3d!([p::Plot], q, r, n̄; kwargs...)\n\nPlot circle in 3 dimensions with center at q, radius r, and perpendicular to normal vector n̄.\n\nExample\n\nq, n = [0,0,0], [0,0,1]\ncirc3d(q, 3, n)\narrow!(q, n)\n\nOr a more complicated one:\n\nZ(r, θ) = 4 - r\nX(r, θ) = r * cos(θ)\nY(r, θ) = r * sin(θ)\nrs = range(0,4, length=10)\nθs = range(0, 2pi, length=100)\nsurface(X.(rs', θs), Y.(rs', θs), Z.(rs', θs); opacity=0.25)\nq = [0,0,2]\nn = [0,0,1]\nr = 2\ncirc3d!(q, r, n; color=\"black\", opacity=0.75)\nq, v̂, ŵ = [0,0,0], [0,4,0], [0,0,4]\nparallelogram!(q, v̂, ŵ; opacity=0.5, color=:yellow)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.circle!-Tuple{Plot, Vararg{Any, 4}}","page":"Reference/API","title":"BinderPlots.circle!","text":"circle([p::Plot], x0, x1, y0, y1; kwargs...)\n\nDraw circle shape bounded in [x0, x1] × [y0, y1]. (Will adjust to non-equal sized boundary.)\n\nExample\n\nUse named tuple for line for boundary.\n\ncircle!(p, 2,3,-1,1; line=(color=:gray,), fillcolor=:red, opacity=0.2)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.contour-Tuple","page":"Reference/API","title":"BinderPlots.contour","text":"contour(x, y, z; kwargs...)\ncontour!([p::Plot], x, y, z; kwargs...)\ncontour(x, y, f::Function; kwargs...)\ncontour!(x, y, f::Function; kwargs...)\ncontourf(x, y, z; kwargs...)\ncontourf!([p::Plot], x, y, z; kwargs...)\ncontourf(x, y, f::Function; kwargs...)\ncontourf!(x, y, f::Function; kwargs...)\n\nCreate contour map.\n\nUse contourf variants for filled contour plot.\nUse seriescolor or palette to pass different colorschemes, e.g. seriescolor=cgrad(:acton).\n\nExample\n\nf(x,y) = sinpi(x*y)*sinpi(x/2 + y)\nys = xs = range(-1,1,200)\ncontourf(xs, ys, f; seriescolor=cgrad(:algae))\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.current-Tuple{}","page":"Reference/API","title":"BinderPlots.current","text":"current()\n\nGet current figure. A Plot object of PlotlyLight; UndefRefError if none.\n\nNot typically needed, as it is implicit in most mutating calls, though may be convenient if those happen within a loop.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.default_size!-Tuple{Int64, Int64}","page":"Reference/API","title":"BinderPlots.default_size!","text":"default_size!(w::Integer,h::Integer)\n\nSpecify default size as percent of allotted screen.\n\nPlotlyLight uses 100, 100 which looks odd in a Jupyter notebook. We set this to 60,120 (so width is 60% of screen size), which seems to look better.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.font-Tuple{BinderPlots.Font}","page":"Reference/API","title":"BinderPlots.font","text":"font(args...)\n\n(This is from Plots.jl)\n\nCreate a Font from a list of features. Values may be specified either as arguments (which are distinguished by type/value) or as keyword arguments.\n\nArguments\n\nfamily: AbstractString. \"serif\" or \"sans-serif\" or \"monospace\"\npointsize: Integer. Size of font in points\nhalign: Symbol. Horizontal alignment (:hcenter, :left, or :right)\nvalign: Symbol. Vertical alignment (:vcenter, :top, or :bottom)\nrotation: Real. Angle of rotation for text in degrees (use a non-integer type). (Works with ticks and annotations.)\ncolor\n\nExamples\n\njulia> font(8)\njulia> font(family=\"serif\", halign=:center, rotation=45.0)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.grid_layout-Tuple{Array{<:Plot}}","page":"Reference/API","title":"BinderPlots.grid_layout","text":"grid_layout(ps::Array{<:Plot})\n\nLayout an array of plots into a grid. Vectors become rows of plots.\n\nUse Plot() to create an empty plot for a given cell.\n\nExample\n\nusing DataFrames\nn = 25\nd = DataFrame(x=sin.(rand(n)), y=rand(n).^2, z = rand(n)) # assume all numeric\nnms = names(d)\nm = Matrix{Plot}(undef, length(nms), length(nms))\n\nfor i ∈ eachindex(nms)\n    for j ∈ eachindex(nms)\n        if j > i\n            p = Plot()\n        elseif j == i\n            x = d[:,j]\n            p = plot(x, seriestype=:histogram)\n            xlabel!(p, nms[j])  # <<- not working in grid! as differe xaxis purposes\n        else\n            x = d[:,i]; y = d[:,j]\n            p = scatter(x, y)\n            xlabel!(p, nms[i]); ylabel!(p, nms[j])\n        end\n        m[i,j] = p\n    end\nend\nplot(m)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.heatmap-Tuple","page":"Reference/API","title":"BinderPlots.heatmap","text":"heatmap(x, y, z; kwargs...)\nheatmap!([p::Plot], x, y, z; kwargs...)\nheatmap(x, y, f::Function; kwargs...)\nheatmap!(x, y, f::Function; kwargs...)\n\nCreate heatmap function of f\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.hline!-Tuple{Any}","page":"Reference/API","title":"BinderPlots.hline!","text":"hline!(y; xmin=0, xmax=1.0; kwargs...)\n\nDraw horizontal line at y. By default extends over the current plot range, this can be adjusted by xmin and xmax, values in [0,1].\n\nThe values for y, xmin, and xmax are broadcast.\n\nA current plot must be made to add to, as the extent of the lines is taken from the current plot.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.hspan!-Tuple{Any, Any}","page":"Reference/API","title":"BinderPlots.hspan!","text":"hspan!([p::Plot], ys; kwargs...)\nhspan!([p::Plot], ys, YS; xmin=0.0, ymin=1.0, kwargs...)\n\nDraw horizontal rectanglular rectangle from ys to YS. By default extends over x range of plot p, though using xmin or xmax can adjust that. These are values in [0,1] and are interpreted relative to the range returned by extrema(p).x.\n\nIf just ys is specified, it is taken as zipped form of (ys, YS). This form is from Plots.jl so use this for compatibility.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.image!-Tuple{Any}","page":"Reference/API","title":"BinderPlots.image!","text":"image!([p::Plot], img_url; [x],[y],[sizex],[sizey], kwargs...)\n\nPlot image, by url, onto background of plot.\n\nx,y,sizex, sizey specify extent via [x, x+sizex] × [y-sizey, y].\npass sizing=\"stretch\" to fill space.\nother arguments cf. plotly examples.\n\nExample\n\nimg = \"https://upload.wikimedia.org/wikipedia/commons/thumb/1/1f/Julia_Programming_Language_Logo.svg/320px-Julia_Programming_Language_Logo.svg.png\"\nplot(;xlims=(0,1), ylims=(0,1), legend=false);\nimage!(img; sizing=\"stretch\")\nplot!(x -> x^2; linewidth=10, linecolor=:black)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.label!-Tuple{Any, Real, Real, Vararg{Any}}","page":"Reference/API","title":"BinderPlots.label!","text":"label!(str, x, y, args...)\n\nA convenience when adding a single annotation:\n\nx,y are coordinates\nlabel is formed by text(str, args...)\n\nExample\n\nplot(sin, 0, pi)\nBinderPlots.label!(\"hi there\", 2, 0.9, :bottom, :right, 20)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.legend!-Tuple{Plot, Nothing}","page":"Reference/API","title":"BinderPlots.legend!","text":"legend!([p::Plot], legend::Bool) hide/show legend\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.parallelogram-Tuple{Any, Any, Any}","page":"Reference/API","title":"BinderPlots.parallelogram","text":"parallelogram(q, v̄, w̄; kwargs...)\nparallelogram!([p::Plot], q, v̄, w̄; kwargs...)\n\nPlot parallelogram formed by two vectors, v̄ and w̄, both anchored at point q.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.plot!-Tuple","page":"Reference/API","title":"BinderPlots.plot!","text":"plot!([p::Plot], x, y; kwargs...)\nplot!([p::Plot], f, a, [b]; kwargs...)\nplot!([p::Plot], f; kwargs...)\n\nUsed to add a new trace to an existing plot. Like Plots.plot!. See plot for argument details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.plot-Tuple","page":"Reference/API","title":"BinderPlots.plot","text":"plot(x, y, [z]; kwargs...)\nplot(f::Function, a, [b]; kwargs...)\nplot(pts; kwargs...)\nplot(x,[y],[z]; seriestype::Symbol=:lines, kwargs...)\n\nCreate a plot, defaulting to a line plot.\n\nReturns a Plot instance from PlotlyLight\n\nFor lines:\n\nx,y,[z] points to plot. NaN values break the line. Can be specified through a container, pts of (xy) or (xyz) values.\na, b: the interval to plot a function over can be given by two numbers or if just a then by extrema(a).\nlabel in legend\nlinecolor: color of line\nlinewidth: width of line\n\nThe line argument allows for magic arguments.\n\nOther keyword arguments include size=(width=X, height=Y), xlims and ylims, legend, aspect_ratio.\n\nProvides an interface like Plots.plot for plotting a function f using PlotlyLight. This just scratches the surface, but PlotlyLight allows full access to the underlying JavaScript library library.\n\nThe provided \"Plots-like\" functions are plot, plot!, scatter!, scatter, annotate!,  title!, xlims! and ylims!.\n\nExample\n\np = plot(sin, 0, 2pi; legend=false)\nplot!(cos)\n# add points\nx0 = [pi/4, 5pi/4]\nscatter!(x0, sin.(x0), markersize=10)\n# add text\nannotate!(tuple(zip(x0, sin.(x0), (text(\"A\",:top), text(\"B\",:top)))...), halign=\"left\", pointsize=12)\ntitle!(\"Sine and cosine and where they intersect in [0,2π]\")\n# adjust limits\nylims!((-3/2, 3/2))\n# add shape\ny0, y1 = extrema(p).y\n[rect!(xᵢ-0.1, xᵢ+0.1, y0, y1, fillcolor=\"gray\", opacity=0.2) for xᵢ ∈ x0]\n# display plot\np\n\nnote: Warning\nYou may need to run the first plot cell twice to see an image.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.plot_implicit-Tuple{Function}","page":"Reference/API","title":"BinderPlots.plot_implicit","text":"plot_implicit(f; xlims=(-5,5), ylims=(-5,5), legend=false, linewidth=2, kwargs...)\nplot_implicit!([p::Plot], f; kwargs...)\n\nFor f(x,y) = ... plot implicitly defined y(x) from f(x,y(x)) = 0 over range specified by xlims and ylims.\n\nExample\n\nf(x,y) = x * y - (x^3 + x^2 + x + 1)\nplot_implicit(f)\n\n(Basically just contour plot with levels=0 and points determined by extrema of xlims and ylims.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.poly-Tuple{Any}","page":"Reference/API","title":"BinderPlots.poly","text":"poly(points; kwargs...)\npoly!([p::Plot], points; kwargs...)\n\nPlot polygon described by points, a container of x-y or x-y-z values. Alternative to creating Shape instance.\n\nExample\n\nf(r,θ) = (r*cos(θ), r*sin(θ))\npoly(f.(repeat([1,2],5), range(0, 2pi-pi/5, length=10)))\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.quiver!","page":"Reference/API","title":"BinderPlots.quiver!","text":"quiver!([p::Plot], x, y, txt=nothing; quiver=(dx, dy), kwargs...)\nquiver(x, y, txt=nothing; quiver=(dx, dy), kwargs...)\n\nDraw 2d arrows. See BinderPlots.arrow! for a single arrow.\n\n(x,y) are tail positions, optionally labeled by txt\nquiver specifies vector part of arrow\nkwargs processarrowhead::Int?,arrowwidth::Int?,arrowcolor`\n\nExample\n\nts = range(0, 2pi, length=100)\np = plot(sin.(ts), cos.(ts), linecolor=\"red\")\nts = range(0, 2pi, length=10)\nquiver!(p, cos.(ts), sin.(ts), quiver=(-sin.(ts), cos.(ts)), arrowcolor=\"red\")\np\n\nThis example shows how text can be rotated with angles in degrees and positive angles measured in a clockwise direction.\n\nts = range(0, 2pi, 100)\np = plot(cos.(ts), sin.(ts), linecolor=\"red\", aspect_ratio=:equal,\n    linewidth=20, opacity=0.2)\n\ntxt = split(\"The quick brown fox jumped over the lazy dog\")\nts = range(0, 360, length(txt)+1)[2:end]\nfor (i,t) ∈ enumerate(reverse(ts))\n    quiver!(p, [cosd(t)],[sind(t)],txt[i],\n            quiver=([0],[0]),\n            textangle=90-t,\n            font=(size=20,))\nend\nxaxis!(zeroline=false); yaxis!(zeroline=false) # remove zerolines\np\n\nnote: 3d arrows\n3d arrows are possible using arrows!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinderPlots.rect!-Tuple{Plot, Vararg{Any, 4}}","page":"Reference/API","title":"BinderPlots.rect!","text":"rect!([p::Plot], x0, x1, y0, y1; kwargs...)\n\nDraw rectangle shape on graphic.\n\nExample [2, 3] × [-1, 1]\n\nrect!(p, 2, 3, -1, 1; linecolor=:gray, fillcolor=:red, opacity=0.2)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.rgb","page":"Reference/API","title":"BinderPlots.rgb","text":"rgb(r,g,b,α=1.0)\nrgb(c::Union{RGB, RGBA}) # RGB[A] from Colors.jl\nrgb(::Symbol, α)\ncolormap(cname, N; kwargs...)\n\nSpecify red, green, blue values between 0 and 255 (as integers). The transparency is specified by the 4th argument, a value in [0.0,1.0].\n\nThe range operator can be used with color to produce a sequence, following Colors.range for RGB[A] values. (It is not lazy, so don't take length to be too large.)\n\nThe colormap function returns a colormap of length 10 using Colors.colormap.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinderPlots.rotate","page":"Reference/API","title":"BinderPlots.rotate","text":"rotate(s::Shape, θ, c=center(s))\nrotate!(s::Shape, θ, c=center(s))\n\nRotate shape about its center ccw by angle θ\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinderPlots.scale","page":"Reference/API","title":"BinderPlots.scale","text":"scale(s::Shape, x, y=x)\nscale!(s::Shape, x, y=x)\n\nScale in x and y direction\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinderPlots.scatter!-Tuple","page":"Reference/API","title":"BinderPlots.scatter!","text":"scatter!([p::Plot], x, y, [z]; kwargs...)\nscatter!([p::Plot], pts; kwargs...)\n\nAdd points to a plot.\n\nmarkershape: shape, e.g. \"diamond\" or \"diamond-open\"\nmarkercolor: color e.g. \"red\"\nmarkersize:  size, as an integer\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.scatter-Tuple","page":"Reference/API","title":"BinderPlots.scatter","text":"scatter(x, y, [z]; [markershape], [markercolor], [markersize], kwargs...)\nscatter(pts; kwargs...)\nscatter!([p::Plot], x, y, [z]; kwargs...)\nscatter!([p::Plot], pts; kwargs...)\n\nPlace points on a plot.\n\nmarkershape: shape, e.g. \"diamond\" or \"diamond-open\"\nmarkercolor: color e.g. \"red\", or :blue, or \"rgba(255, 0, 0, 0.5)\" (a string,a sit passes JavaScript command to plotly.\nmarkersize:  size, as an integer\n\nThe marker keyword has some magic arguments.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.scroll_zoom!-Tuple{Plot, Bool}","page":"Reference/API","title":"BinderPlots.scroll_zoom!","text":"scrollzoom!([p], x::Bool) turn on/off scrolling to zoom\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.size!-Tuple{Plot}","page":"Reference/API","title":"BinderPlots.size!","text":"size!([p::Plot]; [width], [height]) specify size of plot figure\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.skirt-Tuple{Any, Any, Function}","page":"Reference/API","title":"BinderPlots.skirt","text":"skirt(q, v, f::Function; kwargs...)\nskirt!([p::Plot], q, v, f::Function; kwargs...)\nskirt!([p::Plot], xs, ys, zs, f::Function; kwargs...)\n\nAlong a path (xs, ys, zs) plot a skirt between the path and (xs, ys, f(xs, ys)). The case of a path described by a vector, v, anchored at a point q has a special method.\n\nExample\n\nx(r, θ) = r*cos(θ)\ny(r, θ) = r*sin(θ)\nf(x,y) = 4 - x^2 - y^2\nrs, θs = range(0,2,length=10), range(0, 2pi, length=20)\nxs, ys = x.(rs', θs), y.(rs', θs)\nzs = f.(xs, ys)\nsurface(xs, ys, zs, opacity=.2, showscale=false)\n\nq = [0,0,0]\nv = [2,0,0]\nd = skirt!(q, v, f; opacity=0.6)\n\nt = range(0, 1, length=100)\nxs = 2 * t .* sin.(t*pi/2)\nys = 2 * t .* cos.(t*pi/2)\nzs = zero.(xs)\nskirt!(xs, ys, zs, f; color=\"blue\", opacity=0.6)\nskirt!(xs, -ys, zs, f; color=\"blue\", opacity=0.6)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.stroke-Tuple","page":"Reference/API","title":"BinderPlots.stroke","text":"stroke(args...; alpha=nothing)\n\nSpecify line attributes. Returns a Stroke instance.\n\nThis function can be used to specify the attributes of the polygonal line in a shape or other uses of lines.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.surface-Tuple","page":"Reference/API","title":"BinderPlots.surface","text":"surface(x, y, z; kwargs...)\nsurface!(x, y, z; kwargs...)\nsurface(x, y, f::Function; kwargs...)\nsurface!(x, y, f::Function; kwargs...)\n\nCreate surface plot. Pass zcontour=true to add contour plot projected onto the z axis.\n\nExample\n\nf(x,y) = 4 - x^2 - y^2\nxs = ys = range(-2, 2, length=50)\nsurface(xs, ys, f; palette=cgrad(:acton))  # zs = f.(xs', ys); can use seriescolor for palette\n\nExtended help\n\nFrom https://discourse.julialang.org/t/3d-surfaces-time-slider/109673\n\nz1 = Vector[[8.83, 8.89, 8.81, 8.87, 8.9, 8.87],\n                       [8.89, 8.94, 8.85, 8.94, 8.96, 8.92],\n                       [8.84, 8.9, 8.82, 8.92, 8.93, 8.91],\n                       [8.79, 8.85, 8.79, 8.9, 8.94, 8.92],\n                       [8.79, 8.88, 8.81, 8.9, 8.95, 8.92],\n                       [8.8, 8.82, 8.78, 8.91, 8.94, 8.92],\n                       [8.75, 8.78, 8.77, 8.91, 8.95, 8.92],\n                       [8.8, 8.8, 8.77, 8.91, 8.95, 8.94],\n                       [8.74, 8.81, 8.76, 8.93, 8.98, 8.99],\n                       [8.89, 8.99, 8.92, 9.1, 9.13, 9.11],\n                       [8.97, 8.97, 8.91, 9.09, 9.11, 9.11],\n                       [9.04, 9.08, 9.05, 9.25, 9.28, 9.27],\n                       [9, 9.01, 9, 9.2, 9.23, 9.2],\n                       [8.99, 8.99, 8.98, 9.18, 9.2, 9.19],\n                       [8.93, 8.97, 8.97, 9.18, 9.2, 9.18]]\nxs , ys = 1:length(z1[1]), 1:length(z1) # needed here given interface chosen\nsurface(xs, ys, z1, colorscale=\"Viridis\")\nsurface!(xs, ys, map(x -> x .+ 1, z1), colorscale=\"Viridis\", showscale=false, opacity=0.9)\nsurface!(xs, ys, map(x -> x .- 1, z1), colorscale=\"Viridis\", showscale=false, opacity=0.9)\n\nJulia users would typically use a matrix to hold the z data, but Javascript users would expect a vector of vectors, as above. As PlotlyLight just passes on the data to Javascript, the above is perfectly acceptable. Indeed BinderPlots converts matrices to this format in such plots.\n\n(The keyword arguments above come from Plotly, not Plots.)\n\nA parameterized surface can be displayed. Below the unexported unzip function returns 3 matrices specifying the surface described by the vector-valued function r.\n\nimport BinderPlots: unzip\nr1, r2 = 2, 1/2\nr(u,v) = ((r1 + r2*cos(v))*cos(u), (r1 + r2*cos(v))*sin(u), r2*sin(v))\nus = vs = range(0, 2pi, length=25)\nxs, ys, zs = unzip(us, vs, r)\n\nsurface(xs, ys, zs)\n\nPlotting a vertical plane poses a slight challenge, as we can't parameterize as z=f(x,y). Here we intersect a surface with the plane ax + by + 0z = d and add a trace for the intersection of the two surfaces.\n\nf(x, y) = 4 - (x^2 + y^2)\n\n# surface\nxs =  ys = range(-2, 2, length=100)\nzs = f.(xs', ys)\n\n# (vertical) plane\nm, M = extrema(zs)\nzzs = range(m, M, length=2)\nXs = ((x,z) -> x).(xs', zzs)\nZs = ((x,z) -> z).(xs', zzs)\na, b, c, d = 1, 1, 0, 1\nplane(x,z) = (d - a*x - c*z) / b\nYs = plane.(xs', zzs)\n\n# intersection\ny(t) = (d - a*t) / b\nγ(t) = (t, y(t), f(t, y(t)))\n\nsurface(xs, ys, zs)\nsurface!(Xs, Ys, Zs, opacity=0.2)\nplot!(unzip(γ.(xs))...; linewidth=3)\n\n# single transparent color\ncs =  cgrad([parse(Colorant, :seagreen)], alpha=0.25)\nsurface(xs, ys, zs; seriescolor=cs)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.text-Tuple{Any, Vararg{Any}}","page":"Reference/API","title":"BinderPlots.text","text":"text(str, args...; kwargs...)\ntext(str, f::Font)\n\nCreate text with font information to be passed to labeling functions.\n\nf::Font: object produced by font\nargs..., kwargs...: passed to font to create font information. The positional arguments are matched by type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.title!-Tuple{Plot, Nothing}","page":"Reference/API","title":"BinderPlots.title!","text":"title!([p::Plot], txt)\nxlabel!([p::Plot], txt)\nylabel!([p::Plot], txt)\nzlabel!([p::Plot], txt)\n\nSet plot title.\n\ntxt: either a string or a string with font information produced by text.\n\nExample\n\nf = font(20, :red, :left, :bottom, 45.0)\n\np = plot(sin, 0, 2pi)\ntitle!(p, text(\"Plot\", f))\nxlabel!(p, text(\"sine function\", f))\nxticks!(p, 0:pi:2pi, ticklabels = [\"0\", \"π\", \"2π\"], tickfont=f)\nannotate!(p, [(pi, 0, text(\"Zero\", f))])\nquiver!(p, [pi],[1/2], [text(\"zero\",f)], quiver=([0],[-1/2]))\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.translate","page":"Reference/API","title":"BinderPlots.translate","text":"translate(s::Shape, x, y=x)\ntranslate!(s::Shape, x, y=x)\n\nShift shape over by x, up by y\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinderPlots.unzip-Tuple{Any}","page":"Reference/API","title":"BinderPlots.unzip","text":"unzip(v, [vs...])\nunzip(f::Function, a, b)\nunzip(a, b, F::Function)\n\nReshape data to x,y,[z] mode.\n\nIn its basic use, zip takes two vectors, pairs them off, and returns an iterator of tuples for each pair. For unzip a vector of same-length vectors is \"unzipped\" to return two (or more) vectors.\n\nThe function version applies f to a range of points over (a,b) and then calls unzip. This uses the adapted_grid function from PlotUtils.\n\nThe function version with F computes F(a', b) and then unzips. This is used with parameterized surface plots\n\nThis uses the invert function of SplitApplyCombine.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.vline!-Tuple{Any}","page":"Reference/API","title":"BinderPlots.vline!","text":"vline!(x; ymin=0, ymax=1.0; kwargs...)\n\nDraw vertical line at x. By default extends over the current plot range, this can be adjusted by ymin and ymax, values in [0,1].\n\nThe values for x, ymin, and ymax are broadcast.\n\nA current plot must be made to add to, as the extent of the lines is taken from that.\n\nExample\n\nAdd a grid to a plot:\n\np = plot(x -> x^2, 0, 1; aspect_ratio=:equal)\nvline!(0:.1:1, linecolor=:red,  opacity=0.25, linewidth=5)\nhline!(0:.1:1, line=(:blue, 0.75))\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.vspan!-Tuple{Any, Any}","page":"Reference/API","title":"BinderPlots.vspan!","text":"vspan!([p::Plot], xs; kwargs...)\nvspan!([p::Plot], xs, XS; ymin=0.0, ymin=1.0, kwargs...)\n\nDraw vertical rectanglular rectangle from xs to XS. By default extends over y range of plot p, though using ymin or ymax can adjust that. These are values in [0,1] and are interpreted relative to the range returned by extrema(p).y.\n\nIf just xs is specified, it is taken as zipped form of (xs, XS). This form is from Plots.jl so use this for compatibility.\n\nExample\n\np = plot(x -> x^2, 0, 1; legend=false)\nM = 1 # max of function on `[a,b]`\nvspan!(0:.1:0.9, 0.1:0.1:1.0; ymax=[x^2 for x in 0:.1:0.9]/M,\n    fillcolor=:red, opacity=.25)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.wireframe-Tuple","page":"Reference/API","title":"BinderPlots.wireframe","text":"wireframe(x, y, z; kwargs...)\nwireframe(x, y, f::Function; kwargs...)\nwireframe!([p::Plot], x, y, z; kwargs...)\nwireframe!([p::Plot], x, y, f::Function; kwargs...)\n\nCreate wireframe.\n\nExample\n\nf(x, y) = 4 - x^2 - y^2\nxs = ys = range(-2, 2, length=100)\nsurface(xs, ys, f)\nwireframe!(xs, ys, f)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.xaxis!-Tuple{Plot, Vararg{Any}}","page":"Reference/API","title":"BinderPlots.xaxis!","text":"xaxis!([p::Plot]; kwargs...)\nyaxis!([p::Plot]; kwargs...)\nzaxis!([p::Plot]; kwargs...)\n\nAdjust properties of an axis on a chart using Plotly keywords.\n\nticks, ticktext, ticklen, tickwidth, tickcolor, tickfont, showticklabels\nshowgrid, gridcolor, gridwidth\nzeroline, zerolinecolor, zerolinewidth\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.xlabel!-Tuple{Plot, Nothing}","page":"Reference/API","title":"BinderPlots.xlabel!","text":"xlabel!([p::Plot], txt::Union{String, TextFont})\nylabel!([p::Plot], txt::Union{String, TextFont})\nzlabel!([p::Plot], txt::Union{String, TextFont})\n\nSet axis label. Use a text object to specify font information.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.xlims!-Tuple{Plot, Any}","page":"Reference/API","title":"BinderPlots.xlims!","text":"xlims!(p, lims) set x limits of plot\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.xticks!-Tuple{Plot, Nothing}","page":"Reference/API","title":"BinderPlots.xticks!","text":"xticks!([p::Plot], ticks; [ticklabels], [tickfont], kwargs...)\nyticks!([p::Plot], ticks; [ticklabels], [tickfont], kwargs...)\nzticks!([p::Plot], ticks; [ticklabels], [tickfont], kwargs...)\n\nSet ticks. Optionally add labels using a matching length container. Passing a Font object to tickfont will set the font.,\n\nticks: a range of collection of tick positions\nticklabels: if given, a matching length collection of strings\ntickfont: a Font instance to adjust font of all specified ticks.\nkwargs...: passed to [xyz]axis! method.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.ylims!-Tuple{Plot, Any}","page":"Reference/API","title":"BinderPlots.ylims!","text":"ylims!(p, lims) set y limits of plot\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.ziptie-NTuple{6, Any}","page":"Reference/API","title":"BinderPlots.ziptie","text":"ziptie(xs, ys, zs, xs′, ys′, zs′; kwargs...)\nziptie!([p::Plot], xs, ys, zs, xs′, ys′, zs′; kwargs...)\n\nSurface created by connecting points along two paths given by (xs, ys, zs) and (xs′, ys′, zs′). All vectors must be same length. Mesh is created by zipping together points on the two curves. Makie docs refer to this as a ruled surface.\n\nExample\n\nr(t) = (sin(t), cos(t), t)\ns(t) = (sin(t+pi), cos(t+pi), t)\nts = range(0, 4pi, length=100)\nziptie(unzip(r.(ts))..., unzip(s.(ts))...;\n       color=\"green\", opacity=.25, showscale=false)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.zlims!-Tuple{Plot, Any}","page":"Reference/API","title":"BinderPlots.zlims!","text":"zlims!(p, lims) set z limits of plot\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.★-NTuple{4, Any}","page":"Reference/API","title":"BinderPlots.★","text":"★(q, xs, ys, zs; kwargs...)\n★!([p::Plot], q, xs, ys, zs; kwargs...)\n\nA star connected region has an origin, q, for which each boundary point (described by (xs, ys, zs) is accessible by a ray for q which does not cross the boundary.\n\nExample\n\npts = 5\nΔ = 2pi/pts/2\na, A = 1, 3\nq = [0,0,0]\nts = range(0, 2pi, length=pts+1)\nps = [(A*[cos(t),sin(t),0], a*[cos(t+Δ), sin(t+Δ), 0]) for t in ts]\nxs, ys, zs = unzip(collect(Base.Iterators.flatten(ps)))\n★(q, xs, ys, zs)\n\n\n\n\n\n","category":"method"},{"location":"three-d-graphics/#3-dimensional-graphs","page":"3D graphics","title":"3 dimensional graphs","text":"The initial graphics of calculus involve the x-y plane but eventually the visualizations require a z direction. This is because functions fR rightarrow R are graphed in x-y values, but functions such as fR^2 rightarrow R or fR rightarrow R^3 naturally use the third dimension.","category":"section"},{"location":"three-d-graphics/#Parametric-line-plots-(space-curves)","page":"3D graphics","title":"Parametric line plots (space curves)","text":"Parametric line plots show the graph of fR rightarrow R^3 by a plot linking the points (x(t) y(t) z(t)).\n\nParametric plots can be easily created by using a tuple of functions, as in:\n\nusing BinderPlots # load package if not loaded\nusing PlotlyDocumenter # hide\n\nversion = BinderPlots.PlotlyLight.plotly.version # hide\nPlotlyDocumenter.change_default_plotly_version(version) # hide\nnothing # hide\n\nplot((sin, cos, x -> x), 0, 4pi)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide\n\n(The use of tuples to pair functions is idiosyncratic; the Plots.jl style of passing functions for the first 3 (or 2) positional arguments is also supported.)\n\nAs with 2-dimensional lines, the arguments linecolor, linewidth, linestyle, and lineshape from Plots are available.\n\nUsing a single function returning a point may be more natural for some usages. Below we use BinderPlots.unzip to take a container of points into 3 containers for the coordinates, x, y, z to pass to plot(x,y,z) (this could also be just plot(r.(ts)). but that interface is not available in Plots.jl):\n\nr(t) = (sin(t), cos(t), t)\nrp(t) = (cos(t), -sin(t), 1)\n\nts = range(0, 4pi, length=251)\nplot(BinderPlots.unzip(r.(ts))...; legend=false)\nts = range(0, 4pi, length=10)\nBinderPlots.arrow!(r.(ts), rp.(ts))\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide\n\nIn the above we used arrow!, with a collection of tails and vectors, to indicate the tangent direction. The arrow! function hacks together an arrow, as there is no underlying 3-dimensional arrow in Plotly.\n\nnote: arrow!\nThe cones used for the arrow heads are not always scaled properly.","category":"section"},{"location":"three-d-graphics/#Visualizing-f:R2-\\rightarrow-R","page":"3D graphics","title":"Visualizing fR^2 rightarrow R","text":"Functions of the two variables which return a single, scalar value can be visualized in different ways. Using 3 dimensions one can use the x-y plane to denote the inputs and the z axis the value forming a surface. In 2 dimensions the value can be represented a few ways: using colors, as with heatmaps, or using a line to show (xy) values with the same z value, as with contour maps.\n\nContour, heatmaps, and surface plots can be produced by contour, heatmap, and surface. Some examples here use the peaks function of MATLAB:\n\nfunction peaks(x,y)\n    z = 3 * (1-x)^2 * exp(-(x^2) - (y+1)^2)\n    z = z - 10 * (x/5 - x^3 - y^5) * exp(-x^2-y^2)\n    z = z - 1/3 * exp(-(x+1)^2 - y^2)\nend\n\nA contour graph can be made by specifying a grid of points through a selection of x and y values (utilizing range, as below, is one such way) and the function (of two variables) in a direct manner:\n\nxs = range(-3, 3, length=100)\nys = range(-2, 2, length=100)\ncontour(xs, ys, peaks)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"section"},{"location":"three-d-graphics/#Contour-graphs","page":"3D graphics","title":"Contour graphs","text":"The contour lines are automatically selected. Passing a range to the levels argument allows a user choice. Contour plots can be filled with colors. Passing fill=true is all it takes (or calling with contourf):\n\ncontour(xs, ys, peaks; levels=-3:3, fill=true, colorscale=\"Picnic\")\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide\n\nThe levels argument can be a range (something with a step method, like -3:3) or a single number.\n\nThe linewidth argument can adjust the width of the contour lines. The contour_labels argument indicates if the contours should be labeled. The colorbar argument indicates if the colorbar scale should be drawn. (The Plotly counterpoint is showscale.)\n\nThe Plots.jl argument fill is used to indicate if the space between the contours should be colored to give more indication of the gradient.\n\nThe Plotly argument colorscale can be one several scales including \"YlOrRd\", \"YlGnBu\", \"RdBu\", \"Portland\", \"Picnic\", \"Jet\", \"Hot\", \"Greys\", \"Greens\", \"Bluered\", \"Electric\", \"Earth\", \"Blackbody\", \"Viridis\", and \"Cividis\".","category":"section"},{"location":"three-d-graphics/#Heatmaps","page":"3D graphics","title":"Heatmaps","text":"A heatmap uses color variation, not contour lines, to indicate the differences in z values. As with contour, the colorscale argument is passed to Plotly:\n\nheatmap(xs, ys, peaks; colorscale=\"Hot\")\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"section"},{"location":"three-d-graphics/#Implicitly-defined-functions","page":"3D graphics","title":"Implicitly defined functions","text":"The equation f(xy) = 0 for a fixed x may have many y values for a solution. However, locally for most points and nice functions f there is an implicitly defined function y(x). This is useful, say if a tangent line is sought. The plot_implicit function can be used to show implicitly defined function given by f(xy)=0. It is basically a contour plot with only a 0 level.\n\nThe implementation only asks for a range of x and y values to search over. It chooses the number of intermediate points. The ranges are specified through the arguments xlims and ylims with defaults yielding the region -55 times -55.\n\nFor example:\n\nplot_implicit(peaks; xlims=(-3,3), ylims=(-3,3))\n\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"section"},{"location":"three-d-graphics/#Surface-plots","page":"3D graphics","title":"Surface plots","text":"By surface plot we mean a representation of a 2 dimensional structure within 3 dimensions, as can be visualised.\n\nThere are two primary ways of generating these:\n\nA bivariate, scalar function f R^2 rightarrow R can be visualized with the x-y plane showing the inputs and the z axis the values.\nA parametric description with some function F(uv) = langle X(uv) Y(uv) Z(uv) rangle.\n\nWe illustrate each:\n\nThe peaks function can be viewed as easily as the following using surface, where like contour, the xs and ys show where on the x and y axis to sample:\n\nxs = range(-3, 3, length=100)\nys = range(-2, 2, length=100)\n\nsurface(xs, ys, peaks)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide\n\nAttributes are easily adjusted:\n\nsurface(xs, ys, peaks; zcontour=true, showscale=false)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide\n\nParametric surfaces can be produced as follows, where, in this usage, BinderPlots.unzip creates 3 matrices to pass to surface:\n\nr1, r2 = 2, 1/2\nr(u,v) = ((r1 + r2*cos(v))*cos(u), (r1 + r2*cos(v))*sin(u), r2*sin(v))\nus = vs = range(0, 2pi, length=25)\n\np = surface(BinderPlots.unzip(us, vs, r)...;\n\taspect_ratio=:equal, showscale=false)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide\n\nThere isn't much support for arguments from the Plots.jl implementation, save:\n\naspect_ratio = :equal sets the underlying aspect ratio to be equal.\n\nMany Plotly arguments are quite useful:\n\nzcontour=true will add a contour graph showing the levels\nopacity makes it easy to set the transparency of the rendered object\neye, center, and up can adjust the camera positioning.\nshowscale=false can be specified to avoid the drawing of a color scale.\n\nThis last example shows how to plot a surface and two planes along with their intersections with the surface emphasized. The latter uses the Contours package. One plane has the form ax + by + cz = d which for non-zero c has z(x,y) solvable and is visualized through surface. The intersection of the surface and the plane is the 0-level contour of the function f(xy) - z(xy).\n\nThe other plane has c=0, so is plotted differently. That plane is described as lying in the direction of the vectors ab0 and 001 and going through the point x_0 y_0 0. This gives b(x-x_0) - a(y-y_0) = 0. We plot this parametrically. The intersecion can be found by projecting the line in the x-y plane onto the surface.\n\nf(x, y) = 4 - x^2 - y^2\n\nxs = ys = range(-2, 2, length=100)\nsurface(xs, ys, f; legend=false, showscale=false)\n\n# plane of the from a*x + b*y + c*z = d, c != 0\na,b,c,d = 1,1,1,2.5\nz(x,y) = (d - a*x - b*y) / c\nsurface!(xs, ys, z, opacity=0.25, showscale=false)\n\n# One way to plot intersection numerically\nimport Contour\ncs = Contour.contours(xs, ys, ((x,y) -> f(x,y) - z(x,y)).(xs', ys), [0])\nfor cl ∈ Contour.levels(cs)\n    for line in Contour.lines(cl)\n        xₛ, yₛ = Contour.coordinates(line) # coordinates of this line segment\n        plot!(xₛ, yₛ, z.(xₛ, yₛ), linecolor=\"black\", linewidth=10)\n    end\nend\n\n# plane parallel to [a,b,0], [0,0,1] and through [x0,y0,0]\na,b = 1, 1\nx0, y0 = 0, 0 # origin\n\nzs = range(-4, 4, length=100) # or extrema(z.(xs', ys))\nXs = ((x,z) -> x).(xs', zs)\nZs = ((x,z) -> z).(xs', zs)\n\nc, d = 0, b*x0 - a * y0\nplane(x,z) = (d + a*x - c*z) / b\nYs = plane.(xs', zs)\nsurface!(Xs, Ys, Zs, opacity=0.25, showscale=false)\n\ng(t) = (b*t -d)/a # line in x-y plane\nxxs = xs\nyys = g.(xxs)\nzzs = f.(xxs, yys)\nplot!(xxs, yys, zzs, linewidth=10, linecolor=\"black\")\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"section"},{"location":"#BinderPlots","page":"Home","title":"BinderPlots","text":"Documentation for BinderPlots, a simple plotting package for resource-constrained environments using PlotlyLight.jl to render graphics described with an interface superficially resembling much of that from Plots.jl.\n\nPlotly is a JavaScript library for plotting that is widely used and has supported interfaces for Python, R, and Julia (through PlotlyJS).\nPlotlyLight is a very lightweight package to create Plotly graphs using the JavaScript interface. The JSON structures are readily created using the clever Config constructor on the Julia side.\nPlots.jl is a popular package for plotting in Julia with numerous backends including Plotly.\n\nThis package provides a light-weight plotting alternative to Plots.jl utilizing a subset of the Plots interface. It is inspired by SimplePlots and is envisioned as being useful within resource-constrained environments such as binder.org.\n\nThis is not a re-implementation of Plots; it only bears a superficial resemblance. The Plots package is far more developed in terms of its API, its extendable plot recipes, and its extensions like StatsPlots.jl. The BinderPlots package only provides a small fraction, primarily that part of the interface that makes visualizing functions in low dimensions easier.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"The package is not registered. It may be installed through Pkg.add(url=\"...\")).\n\nOnce installed, the package is loaded in the standard manner.\n\nusing BinderPlots\nusing PlotlyDocumenter # hide\n\nThe package should load very quickly and the time to first plot should be quite speedy as this is the case for PlotlyLight.","category":"section"},{"location":"#Saving-figures","page":"Home","title":"Saving figures","text":"Saving figures is the same as with PlotlyLight.\n\nTo save a figure to HTML, we have:\n\nBinderPlots.PlotlyLight.save(p, \"filename.html\")\n\nTo save a figure to an image file, the PlotlyKaleido package is used:\n\nusing PlotlyKaleido\nPlotlyKaleido.start()\n\n(;data, layout, config) = p;\nPlotlyKaleido.savefig((; data, layout, config), \"myplot.png\")","category":"section"},{"location":"statistics/#Graphics-of-statistics","page":"Statistics","title":"Graphics of statistics","text":"using BinderPlots\nusing PlotlyDocumenter # hide\n\nversion = BinderPlots.PlotlyLight.plotly.version # hide\nPlotlyDocumenter.change_default_plotly_version(version) # hide\nnothing # hide\n\nBoth Plots.jl (through StatsPlots) and Plotly have the ability to easily create some of the basic graphics of statistics. BinderPlots does not attempt to provide an interface for these graphics, rather the underlying Plotly interface would be used. This section shows some example usage.\n\nThe basic graphics of statistics show distributions (what can be and how often that something occurs) and basic relationships (especially between an explanatory and response variable).\n\nIn the following the data is either numeric or categorical. The data may be passed along via the positional arguments of plot or as named arguments to pass directly to PlotlyLight. The plot interface allows for a grouping value, to be described later. Series attributes are passed along through keywords. Some of the graphics require adjustments to the underlying layout.\n\nThe different grqphics we discuss are defined by the seriestype. We have :histogram, :histogram2d, :bar, :pie, :boxplot, in addition to :scatter.\n\nA histogram is a familiar graphic to illustrate the distribution of a single numeric data set. By passing the data in as the x argument the graphic is easy to construct:\n\nx = rand(100)\nplot(x; seriestype=:histogram)\n\nto_documenter(current())           # hide\n\nLater, as an example of translating plotly's JavaScript examples, many variants of histograms are shown.\n\nBar charts show the distribution of categorical variables. The :bar type expects the x value to get the levels and the y value to be the counts. In this example, two such bar charts are made:\n\nanimals = [\"giraffes\", \"orangutans\", \"monkeys\"]\np = plot(animals, [10,20,30]; seriestype=:bar, label=\"Zoo 1\")\nplot!(p, animals, [5,6,8];    seriestype=:bar, label=\"Zoo 2\")\np.layout.barmode=\"group\";\n\nto_documenter(current())           # hide\n\nThe last command sets the :barmode attribute to \"group\" to specify how the two series are presented together.\n\nThe pie chart is a lesser used graphic to illustrate a categorical variable, showing the relative proportion of the categories. The underlying percentage will be computed, so raw counts may be used. The bar chart above use  the generic x and y names for its data; howeverthe Plotly pie chart uses named arguments labels and values:\n\nlabels =[\"a\",\"b\", \"c\"]\nvalues = [19, 26, 55]\nplot(; labels, values, seriestype=:pie, hole=0.4)\n\nto_documenter(current())           # hide\n\nThe graphic above used the hole argument to make donut.\n\nThe box plot, like a histogram, is a graphic to show the distribution of a single numeric variable. It uses a style that highlights just the basic descriptions of a distribution (center, spread, symmetry, skew, ...).\n\nx = randn(100)\nplot(nothing, x; seriestype=:boxplot)\n\nto_documenter(current())           # hide\n\nPassing the data into the first, x,  argument position instructs the drawing of vertical box plots, using the second, y, argument (by padding the first position with nothing) produces  a vertical box plot.","category":"section"},{"location":"statistics/#Relationships,-grouping","page":"Statistics","title":"Relationships, grouping","text":"Statistics graphics are also used to show relationships between variables. In the example of the bar plot, two data sets are shown together. A common format for storing multiple datasets is \"long format\" where data is structured with each row representing a case and each column recording the value of a variable for each case. For the data in the bar plot example, this would be [10, 20, 30, 5, 6, 8], [\"giraffes\", \"orangutans\", \"monkeys\",\"giraffes\", \"orangutans\", \"monkeys\"], and [\"zoo 1\", \"zoo 1\", \"zoo 1\", \"zoo 2\", \"zoo 2\", \"zoo 2\"] to indicate the group. This format lends itself to the \"split-apply-combine\" data processing style where the data is split into groups, a function is applied to each group, and then the results are then combined. For this application, the apply step is to visually represent the grouped data; the combine step displays each series as a whole.\n\nSplitting the data on the grouping variable can be done in different ways. If this variable is passed to the group argument for these graphics, the SplitApplyCombine.group function handles the grouping.\n\nFor example, were the data given in long format, the following call to plot passes the splitting part off:\n\ncnt = [10, 20, 30, 5, 6, 8]\na = [\"giraffes\", \"orangutans\", \"monkeys\",\"giraffes\", \"orangutans\", \"monkeys\"]\ng = [\"zoo 1\", \"zoo 1\", \"zoo 1\", \"zoo 2\", \"zoo 2\", \"zoo 2\"]\n\nplot(a, cnt, group=g, seriestype=:bar)\n\nto_documenter(current())           # hide\n\nThe common workflow would store the variable cnt, a, and g in a data frame. No special handling of data frames is provided by BinderPlots.\n\nWe now use data sampled from the Palmer Penguins data set to illustrate some different graphics.\n\n# Sample from data set available in PalmerPenguins.jl\n\nspecies = [\"Adelie\", \"Adelie\", \"Gentoo\", \"Adelie\", \"Gentoo\", \"Chinstrap\", \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"Gentoo\", \"Chinstrap\", \"Adelie\", \"Adelie\", \"Gentoo\", \"Adelie\", \"Gentoo\", \"Adelie\", \"Gentoo\", \"Adelie\", \"Adelie\", \"Adelie\", \"Gentoo\", \"Adelie\", \"Adelie\", \"Gentoo\", \"Adelie\", \"Adelie\", \"Adelie\", \"Gentoo\"]\n\nisland = [\"Biscoe\", \"Dream\", \"Biscoe\", \"Biscoe\", \"Biscoe\", \"Dream\", \"Biscoe\", \"Torgersen\", \"Biscoe\", \"Torgersen\", \"Biscoe\", \"Dream\", \"Dream\", \"Torgersen\", \"Biscoe\", \"Dream\", \"Biscoe\", \"Biscoe\", \"Biscoe\", \"Biscoe\", \"Torgersen\", \"Dream\", \"Biscoe\", \"Dream\", \"Biscoe\", \"Biscoe\", \"Torgersen\", \"Biscoe\", \"Dream\", \"Biscoe\"]\n\nbill_length_mm = [37.9, 37.2, 45.5, 38.2, 51.1, 51.5, 38.1, 42.8, 41.1, 36.6, 46.8, 45.7, 41.5, 40.9, 46.2, 39.0, 48.8, 40.6, 45.5, 39.6, 36.2, 37.5, 41.7, 38.9, 42.2, 47.6, 46.0, 41.6, 40.7, 46.9]\n\nbill_depth_mm = [18.6, 18.1, 13.7, 20.0, 16.3, 18.7, 17.0, 18.5, 18.2, 17.8, 15.4, 17.0, 18.5, 16.8, 14.9, 18.7, 16.2, 18.6, 14.5, 20.7, 17.2, 18.5, 14.7, 18.8, 19.5, 14.5, 21.5, 18.0, 17.0, 14.6]\n\nbody_mass_g = [3150, 3900, 4650, 3900, 6000, 3250, 3175, 4250, 4050, 3700, 5150, 3650, 4000, 3700, 5300, 3650, 6000, 3550, 4750, 3900, 3150, 4475, 4700, 3600, 4275, 5400, 4200, 3950, 3725, 4875]\n\nsex =[\"female\", \"male\", \"female\", \"male\", \"male\", \"male\", \"female\", \"male\", \"male\", \"female\", \"male\", \"female\", \"male\", \"female\", \"male\", \"male\", \"male\", \"male\", \"female\", \"female\", \"female\", \"male\", \"female\", \"female\", \"male\", \"male\", \"male\", \"male\", \"male\", \"female\"]\n\ndf = (; species, island, bill_length_mm, bill_depth_mm, body_mass_g, sex)\n\nnothing\n\nThe boxplot is a very useful graphic to compare basic features of related distributions. In the following, we look at the body mass split by island:\n\nplot(nothing, df.body_mass_g, group=df.island, seriestype=:boxplot)\n\nto_documenter(current())           # hide\n\nThis shows the same data using a histogram:\n\np = plot(df.body_mass_g, group=df.island, seriestype=:histogram)\np.layout.barmode = \"overlay\"\np\n\nto_documenter(current())           # hide\n\nThe different islands have different species dominate, so the differences are expected. This shows a scatter plot of bill measurements for each species:\n\nplot(df.bill_depth_mm, df.bill_length_mm; group = df.species,\n     seriestype = :scatter,\n     marker = (10, (:red, :blue, :green), (:star, :circle, :square)))\n\nto_documenter(current())           # hide","category":"section"},{"location":"statistics/#Facets","page":"Statistics","title":"Facets","text":"Facet plots show the data using different subplots, where the data is split by faceting variables, similar to group variables.\n\nThe implementation is a bit primitive, but passing one variable to the facet argument, will produce a row of the same graphic for the data subsetted by the levels of the facet variable. Passing two variables in a tuple to the facet argument, will produce a grid of subplots, the columns following levels of the first facetting variable, the rows the levels of the second.","category":"section"},{"location":"statistics/#Histogram-examples","page":"Statistics","title":"Histogram examples","text":"The page https://plotly.com/javascript/histograms/ shows several variants of histograms and the JavaScript code to produce them. This set of examples show how these would be created in BinderPlots. The key is that almost exclusively, the JavaScript interface is followed for the graphics os statistics, outside of scatter plots.","category":"section"},{"location":"statistics/#Basic-histogram","page":"Statistics","title":"Basic histogram","text":"x = rand(500)\nplot(x, seriestype=:histogram)\n\nto_documenter(current())           # hide","category":"section"},{"location":"statistics/#Horizontal","page":"Statistics","title":"Horizontal","text":"This example uses marker to specify a color to the histogram. A Config object is needed to avoid the magic processing of the marker arguments.\n\ny = rand(500)\nplot(nothing, y,seriestype=:histogram,  marker=Config(color=:pink)) # not recycled\nto_documenter(current())           # hide","category":"section"},{"location":"statistics/#Overlaid-Histogram","page":"Statistics","title":"Overlaid Histogram","text":"This example uses two histogram calls. The arrangement of the two graphics is passed to the barmode attribute of the layout:\n\nx = 1 .+ rand(500)\nx1 = 1.1 .+ rand(500)\np = plot(x, seriestype=:histogram, label=\"trace0\",\n   marker=Config(color=:green), opacity=0.5)\nplot!(p, x1, seriestype=:histogram, label=\"trace1\",\n   marker=Config(color=:red), opacity=0.5)\np.layout.barmode=:overlay\np\n\nto_documenter(current())           # hide","category":"section"},{"location":"statistics/#Stacked-Histograms","page":"Statistics","title":"Stacked Histograms","text":"The :stack style for barmode has a different display:\n\nx = rand(500)\nx1 = rand(500)\np = plot(x, seriestype=:histogram, label=\"trace0\")\nplot!(p, x1, seriestype=:histogram, label=\"trace1\")\np.layout.barmode=:stack\np\n\nto_documenter(current())           # hide","category":"section"},{"location":"statistics/#Colored-and-Styled-Histograms","page":"Statistics","title":"Colored and Styled Histograms","text":"This example passes more style arguments to marker. It also has to work around the fact that the Config constructor has some issues when a reserved keyword, like end, is used.\n\nk = rand(500)\nx1 = 5 * k\nx2 = 10 * k\ny1 = k\ny2 = 2k\n\nxbins = Config(start=0.5, size=0.06)\nxbins.end=2.8 # <-- why we can't use Config(start=0.5, size=0.06, end=2.8)\n\np = plot(x1, y1;\nseriestype=:histogram,\nlabel=\"control\",\nautobinx = false, histnorm=\"count\",\nmarker = Config(color=rgb(255, 100, 102, 0.7),\n                line=Config(color=rgb(255, 100, 102, 1.0), width=1)),\nopacity=0.5,\nxbins\n)\n\nxbins.start, xbins.end = -3.2, 4\nplot!(x2, y2;\nseriestype=:histogram,\nlabel = \"experimental\",\nautobinx = false,\nmarker = Config(color=rgb(100, 200, 102, 0.7),\n                line = Config(color=rgb(100, 200, 102, 1.0), width=1)),\nxbins,\nopacity = 0.75\n)\n\nfor (k,v) ∈ pairs((bargap=0.05, bargroupgap=0.2, barmode=\"overlay\",\n  title = \"sampled results\"))\n  p.layout[k] = v\nend\nxlabel!(p, \"Value\")\nylabel!(p, \"Count\")\np\n\nto_documenter(current())           # hide","category":"section"},{"location":"statistics/#Cumulative-Histogram","page":"Statistics","title":"Cumulative Histogram","text":"x = rand(500)\nplot(x; seriestype=:histogram,\n        cumulative=Config(enabled=true))\n\nto_documenter(current())           # hide","category":"section"},{"location":"statistics/#Normalized-Histogram","page":"Statistics","title":"Normalized Histogram","text":"x = rand(500)\nplot(x; seriestype=:histogram,\n        histnorm=\"probability\",\n        marker = Config(color=rgb(255,255,100)))\n\nto_documenter(current())           # hide","category":"section"},{"location":"statistics/#Specify-Binning-Function","page":"Statistics","title":"Specify Binning Function","text":"x = [\"Apples\",\"Apples\",\"Apples\",\"Oranges\", \"Bananas\"]\ny = [\"5\",\"10\",\"3\",\"10\",\"5\"]\nplot(x,y; seriestype=:histogram,\n     histfunc=\"count\", label=\"count\")\nplot!(x,y; seriestype=:histogram,\n     histfunc=\"sum\", label=\"sum\")\n\nto_documenter(current())           # hide","category":"section"}]
}

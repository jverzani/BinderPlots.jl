var documenterSearchIndex = {"docs":
[{"location":"three-d-shapes/#Three-dimesional-shapes","page":"3D shapes","title":"Three dimesional shapes","text":"","category":"section"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"using BinderPlots\nusing PlotlyDocumenter # hide\n\nversion = BinderPlots.PlotlyLight.plotly.version # hide\nPlotlyDocumenter.change_default_plotly_version(version) # hide\nnothing # hide","category":"page"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"note: Not `Plots` inspired\nThe three dimensional shapes discussed here are developed without paying attention to any Plots.jl interfaces.","category":"page"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"Many surfaces are easily described in turns of being the graph of a function fR^2 rightarrow R or in turns of a parameterization F(uv) = langle X(uv) Y(uv) Z(uv) rangle. The surface function readily plots such. However, some surfaces can be more easily described otherwise, and BinderPlots attempts to provide some interface in a few cases.","category":"page"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"Rather than use the surface type, the following use the mesh3d type which requires a triangularization of the desired surface. Two types of surfaces that are easily triangulated are:","category":"page"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"\"star-shaped\" surfaces defined by a boundary, described by xs, ys, zs, and a point p (a vector) with the property that the line segment connecting p to a boundary point does not cross any other boundary point. A simple example is a disc with p being the origin. The triangulation is easy to visualize, the vertices being the origin and adjacent points on the boundary (which is of course discretized by the data).\nThe surface between two space curves defined by selecting n points on each and connecting the points by a line. Paired adjacent points form \"rectangles\" that are easily triangulated.  This is an example of a ruled surface between two space curves. (A star shape is a ruled surface with one of the curves being just a point.)","category":"page"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"The underlying functions have the odd names ★ (i.e., \\bigstar[tab]) and ziptie, along with their ! counterparts.","category":"page"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"These are used to provide the following shapes","category":"page"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"parallelogram)q, u, v)! which draws the planar region formed by two vectors u and v anchored at a point q.\ncirc3d!(q, r, n) which draws the disc with origin q, radius r and normal to a vector n\nskirt! which forms a surface defined by an underlying path (either the vector v anchored at q or by values xs, ys, zs) and the paths projection onto the surface of f(x,y)\nband! is an alternative interface, borrowed from Makie, to ziptie!","category":"page"},{"location":"three-d-shapes/#Intersection-of-3-planes","page":"3D shapes","title":"Intersection of 3 planes","text":"","category":"section"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"The parallelogram function allows planes to easily be described. Contrast the following to an example in the previous section when a plane ax + by = d was described as a parametric surface in order to graph it with surface. Here such planes are described by two orthogonal vectors.","category":"page"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"parallelogram( [-1,-1,0], [2,0,0], [0,2,0])\nparallelogram!([-1,0,-1], [0,0,2], [2,0,0])\nparallelogram!([0,-1,-1], [0,2,0], [0,0,2])\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"The choice of shapes is done to facilitate certain graphics of calculus.","category":"page"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"For example, to illustrate the method of finding volumes by slices a figure like the following might be of interest:","category":"page"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"f(r, u) = 4 - r\nrs = range(0, 4, length=25)\nus = range(0, 2pi, length=25)\nX(r, u) = r * sin(u)\nY(r, u) = r * cos(u)\n\nsurface(X.(rs', us), Y.(rs', us), f.(rs', us), opacity=0.25)\n\nq, n = [0,0,2], [0,0,1]\ncirc3d!(q, 2, n, opacity=0.5, color=\"blue\")\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"That utilizes circ3d! to draw a disc with normal vector in the direction of the z axis.","category":"page"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"Whereas, this next graphic utilizes skirt! to highlight the intersection of the plane x=-1with surface.","category":"page"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"f(x, y) = 1 + cospi(x) + cospi(y)\nxs = ys = range(-1, 1, 100)\n\nsurface(xs, ys, f; opacity=0.25)\n\n# draw skirt between surface and the line p + t*v\np, v = [-1/2,-1,0], [0, 2, 0]\nskirt!(p, v, f; opacity = 0.5, color=:black)\n\n# draw intersection of plane and surface\nr(t) = p + t * v\nts = range(0, 1, length=100)\nxs, ys, _ = BinderPlots.unzip(r.(ts))\nzs = f.(xs, ys)\nplot!(xs, ys, zs, linewidth=10)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"The underlying mesh functions can be of use as well.","category":"page"},{"location":"three-d-shapes/#Helix","page":"3D shapes","title":"Helix","text":"","category":"section"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"The ziptie function lends itself to drawing an helix (or fusili if you are hungry):","category":"page"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"r(t) = (sin(t), cos(t), t)\ns(t) = (sin(t+pi), cos(t+pi), t)\nts = range(0, 4pi, length=100)\n\nziptie(BinderPlots.unzip(r.(ts))..., BinderPlots.unzip(s.(ts))...;\n       color=\"green\", opacity=.25, showscale=false)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"This is  a related spiraling ribbon using band:","category":"page"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"r(t) = (sin(t), cos(t), t)\ns(t) = (sin(t)/2, cos(t)/2, t)\nts = range(0, 4pi, length=100)\n\nband(r.(ts), s.(ts);\n       color=\"seafoam\", opacity=.25, showscale=false)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"three-d-shapes/#Star-shapes","page":"3D shapes","title":"Star shapes","text":"","category":"section"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"This shape is reminiscent of a potato chip, though formed with lines drawn from [0,0,0]:","category":"page"},{"location":"three-d-shapes/","page":"3D shapes","title":"3D shapes","text":"r(t) = (sin(t), 2cos(t), sin(2t))\nts = range(0, 2pi, 100)\n\n★([0,0,0], BinderPlots.unzip(r.(ts))...)\nplot!(BinderPlots.unzip(r.(ts))..., linewidth=10)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"basic-graphics/#Basics-of-BinderPlots","page":"Basics","title":"Basics of BinderPlots","text":"","category":"section"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The plotting interface provided picks some of the many parts of Plots.jl that prove useful for the graphics of calculus and provides a stripped-down, though reminiscent, interface around PlotlyLight, a package which otherwise is configured in a manner very-much like the underlying JavaScript implementation. The Plots package is great – and has a Plotly backend – but for resource-constrained usage can be too demanding.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Some principles of Plots are:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The Plots.jl interface uses positional arguments for data (with data possibly including reference to some existing figure) and keyword arguments for modifying underlying attributes.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The BinderPlots.jl interface mostly follows this. However, only some of the Plots.jl keyword arguments are supported. Other keyword arguments are passed directly to Plotly and so should follow the naming conventions therein.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The PlotlyLight interface is essentially the JavaScript interface for Plotly only with the cleverly convenient Config constructor used to create the nested JavaScript data structures needed through conversion with JSON3. All arguments are like keyword arguments.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"In Plots.jl, every column is a series, a set of related points which form lines, surfaces, or other plotting primitives.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Plotly refers to series as traces. This style is mostly supported in BinderPlots. Using multiple layers is suggested, but matrices can be used to specify multiple series.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"In Plots.jl for keyword arguments many aliases are used, allowing for shorter calling patterns for experienced users.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Many, but not all, of the aliases are available. (The shorter ones are not, as they are as cryptic as magic arguments and more work to type.)","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"In Plots.jl some arguments encompass magic arguments for setting many related arguments at the same time.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"BinderPlots allows for magic arguments.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"In Plots.jl the available plot types are specified through seriestype and there are shorthands to produce different methods (e.g., scatter is a shorthand for the seriestype :scatter.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"This is only partially the case with BinderPlots, as not all plot types have a shorthand defined.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Altogether, most basic graphics created through Plots can be produced with BinderPlots, but of the showcase of 66 examples, which utilize many corners of the Plots.jl interface, only about 23 are fully runnable.","category":"page"},{"location":"basic-graphics/#Supported-plotting-functions","page":"Basics","title":"Supported plotting functions","text":"","category":"section"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"We load the package in the typical manner:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"using BinderPlots\nusing PlotlyDocumenter # hide","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"This package directly implements some of the Plots recipes for functions that lessen the need to manipulate data.","category":"page"},{"location":"basic-graphics/#plot(f,-a,-b)","page":"Basics","title":"plot(f, a, b)","text":"","category":"section"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The plot function from PlotlyLight is given several methods through dispatch to create line graphs.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The simplest means to plot a function f over the interval [a,b] is the declarative pattern plot(f, a, b). For example:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"plot(sin, 0, 2pi)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The sin object refers to a the underlying function to compute sine. More commonly, the function is user-defined as f, or some such, and that function object is plotted.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The interval may be specified using two numbers or with a container, in which case the limits come from calling a method of extrema for Plot objects. A default of (-55) is used when no interval is specified.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"For line plots, as created by this usage, the supported key words include","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"linecolor to specify the color of the line; linealpha for the transparency\nlinewidth to adjust width in pixels\nlinestyle to adjust how line is drawn\nlineshape to adjust how the line is interpolated between adjacent points\nlabel can be used to name the entry for given trace, unless legend=false has been specified","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"note: Note\nAll plotting functions in BinderPlots return an instance of PlotlyLight.Plot. These objects can be directly modified and re-displayed. The show method creates the graphic for viewing. The current function returns the last newly created plot.","category":"page"},{"location":"basic-graphics/#plot(xs,-ys,-[zs])-or-plot(pts)","page":"Basics","title":"plot(xs, ys, [zs]) or plot(pts)","text":"","category":"section"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The points to plot may be specified directly.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Points can be given as (x_1 y_1) (x_2y_2) dots (x_n y_n) or as two vectors (x_1 x_2 dots x_n) and (y_1 y_2 dots y_n). When the latter, they must be of equal length, as internally they are paired off.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"For example, we might bypass the automatic selection of points to plot and create these directly:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"xs = range(0, pi, length=251)\nf(x) = sin(sin(x^2))\nys = f.(xs)\nplot(xs, ys)\n\ng(x) = (x, sin(sin(x^3)))\nplot!(g.(xs))\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"At times it is more convenient to generate pairs of points. In the above example, g returns (xy) pairs. Tuples and other non-vector containers of points can be plotted directly, as just shown.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The plot(xs, ys) function simply connects the points (x_1y_1) (x_2y_2) dots  sequentially with lines in a dot-to-dot manner (the lineshape argument can modify this). If values in y are non finite, then a break in the dot-to-dot graph is made.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Use plot(xs, ys, zs) for line plots in 3 dimensions, which is illustrated in a different section.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"If one or more x or y (or z) is a matrix, then each column will be treated as specifying a trace. In this case, most keyword arguments will be cycled over including the magic arguments. For example:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"m, n = 10, 3\nx = 1:m\ny = rand(m, n)\nplot(x, y; label=(\"one\",\"two\",\"three\"), linecolor=(:red, :green, :blue))\n\nto_documenter(current())           # hide","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"note: Note\nIt is a bit subtle, but a vector of vectors is treated as holding multiple series; whereas a vector of tuples (or other containers) is treated as a collection of points.","category":"page"},{"location":"basic-graphics/#plot!","page":"Basics","title":"plot!","text":"","category":"section"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Layers can be added to a figure created by plot. The notation follows Plots.jl and uses Julia's convention of indicating functions which mutate their arguments with a !. The underlying plot is mutated (by adding a layer) and reference to this may or may not be in the plot! call. (When missing, the current plotting figure, determined by current(), is used.)","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"plot(sin, 0, 2pi)\n\nplot!(cos)    # no limits needed, as they are computed from the current figure\n\nplot!(x -> x, 0, pi/2)      # limits can be specified\nplot!(x -> 1 - x^2/2, 0, pi/2)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"basic-graphics/#plot([f,g,...],-a,-b)","page":"Basics","title":"plot([f,g,...], a, b)","text":"","category":"section"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"As a convenience, to plot two or more traces in a graphic, a vector of functions can be passed in. In which case, each is plotted over the interval. (Similar to using plot to plot the first and plot! to add the rest.)","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The Plots keyword line arguments are recycled. For more control, using plot!, as above.","category":"page"},{"location":"basic-graphics/#plot(fs::NTuple{N,Function},-a,-b)","page":"Basics","title":"plot(fs::NTuple{N,Function}, a, b)","text":"","category":"section"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Two dimensional parametric plots show the trace of (f(t) g(t)) for t in ab. These are easily created by plot(x,y) where the x and y values are produced by broadcasting, say, such as f.(ts) where ts = range(a,b,n).","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"note: Not encouraged\nThe Plots.jl convenience signature is plot(f::Function, g::Function, a, b). This is supported but with a warning indicating it is best to pass a tuple of functions, as in plot((f,g), a, b).","category":"page"},{"location":"basic-graphics/#plot(::Array{:Plot,N})-or-plot(::Plot...)","page":"Basics","title":"plot(::Array{<:Plot,N}) or plot(::Plot...)","text":"","category":"section"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Arrange an array of plot objects into a regular layout for display.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"(Plots.jl uses a different convention.)","category":"page"},{"location":"basic-graphics/#plot(;-seriestype::Symbol,-kwargs...)","page":"Basics","title":"plot(; seriestype::Symbol, kwargs...)","text":"","category":"section"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"There are a few series types for which the underlying PlotlyLight Plot function is basically called. A few examples from statistics, might be:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"p1 = plot(; values = [19, 26, 55], labels=[\"a\",\"b\", \"c\"], seriestype=:pie)\np2 = plot(randn(100); seriestype=:histogram)\np3 = plot(nothing, randn(100); seriestype=:boxplot)\nanimals = [\"giraffes\", \"orangutans\", \"monkeys\"]\np4 = plot(animals, [10,20,30]; seriestype=:bar, label=\"Zoo 1\")\nplot!(p4, animals, [5,6,8];    seriestype=:bar, label=\"Zoo 2\")\np4.layout.barmode=\"group\";\n\nplot([p1 p2; p3 p4])   # lost labels are a bug; only shows 1 plot in docs\n\nto_documenter(current())           # hide","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The keyword arguments defined within this package are processed; the rest passed onto the data configuration of Plotly. The bar plot required a specification of the layout configuration.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"note: seriestype\nThe seriestype argument refers to a plotly type and mode which could be specified directly. For example, plot(x,y; type=\"scatter\", mode=\"markers+lines\", ...) would produce a scatter plot along with lines connecting the points.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"This task can be done by either combining  plot with scatter! (introduced next) or passing seriestype=[:lines, :scatter].","category":"page"},{"location":"basic-graphics/#scatter(xs,-ys,-[zs])-or-scatter(pts)","page":"Basics","title":"scatter(xs, ys, [zs]) or scatter(pts)","text":"","category":"section"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Save for a few methods, the plot method represents the data with type line which instructs Plotly to connect points with lines.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Related to plot and plot! are scatter and scatter!; which render just the points, without connecting the dots.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The following Plots.jl marker attributes are supported:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"markershape to set the shape\nmarkersize to set the marker size\nmarkercolor to adjust the color; markeralpha for its transparency level","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"A specification like marker=(:diamond, 20, :blue, 0.75) will set the four attributes above with matching by type. (The set of marker shapes is extensive, but this package does not allow the aliases used by Plots.jl. Eg, :d for :diamond or :hex for :hexagon.)","category":"page"},{"location":"basic-graphics/#Text-and-arrows","page":"Basics","title":"Text and arrows","text":"","category":"section"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The annotate!, quiver!, arrow and arrow! functions are used to add text and/or arrows to a graphic.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The annotate! function takes a a tuple of (x,y,txt) points or vectors of each and places text at the x-y coordinate. Text attributes can be adjusted.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The quiver! function plots arrows with optional text labels. Due to the underlying use of Plotly, quiver is restricted to 2 dimensions. The arguments to quiver are tail position(s) in x and y and arrow lengths, passed to quiver as dx and dy. The optional txt argument can be used to label the anchors.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The BinderPlots.arrow! function is not from Plots.jl. It provides a different interface to arrow drawing than quiver. For BinderPlots.arrow! the tail and vectors are passed in as vectors. (so for a single arrow from p=[1,2] with direction v=[3,1] one call would be arrow!(p, v) (as compared with quiver([1],[2], quiver=([3],[1]))). The latter more efficient for many arrows.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The BinderPlots.arrows! function borrows the Makie.jl interface to specify an arrow (basically arrows!(x,y,u,v) is quiver!(x,y,quiver=(u,v)).","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The following Plots.jl text attributes are supported:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"color\nfamily\npointsize\nrotation","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"For labels and annotations, the call text(str, args...) can be used to specify font properties. For example text(\"label\", :red, 20) specifies the color and text size for the string when used to label a graphic. The font function takes the args... and returns a Font object, which allow various text attributes to be customized.","category":"page"},{"location":"basic-graphics/#Shapes","page":"Basics","title":"Shapes","text":"","category":"section"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The Shape constructor can be used to specify a polygon, as with Shape(xs, ys). There are a few built-in shapes available by specifying symbol (e.g. Shape(:diamond) or Shape(:unitsquare).","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"These Shape instances can be manipulated by translate, rotate, scale, shear, and their mutating versions. As well there is invert! and center!.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"These need to be qualified, or can be imported with this command:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"import BinderPlots: translate, translate!, rotate, rotate!, scale, scale!, shear, shear!, invert!, center!","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The following create regions which can be filled.  Shapes have an interior and exterior boundary. The exterior line has attributes that can be adjusted with linecolor, linewidth, and linestyle.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The following Plots.jl fill attributes are supported:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"fillcolor a color, use rgb to specify a color with alpha level, e.g. rgb(:green, 0.25) (this is like Plots.plot_color, but more general as rgb also takes RGB values in the range 0 to 225.\nfillrange one of :none, :tozerox, :tonextx, :tozeroy (or 0), :tonexty, :toself, :tonext. The default for Shape instances is :toself.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Use stroke to specify attributes for the enclosing polygonal line.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"note: Note\nUnlike Plots.jl Shape instances can not be used directly as marker shapes.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Other plotting commands that create 2d-regions are:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"rect!(x0, x1, y0, y1) draws a rectangle between (x0, y0) and (x1, y1).\nhspan!(ys, YS; xmin=0.0, xmax=1.0) draws horizontal rectangle(s) with bottom and top vertices specified by ys and YS. (A different calling style than Plots.jl.)\nvspan!(xs, XS; ymin=0.0, ymax=1.0) draws vertical rectangle(s) with left and right vertices specified by xs and XS.\ncircle!(x0, x1, y0, y1) draws a \"circular\" shape in the rectangle given by (x0, y0) and (x1, y1).\npoly!(points; kwargs...) where points is a container of (xy) or (xyz) coordinates. Alternate to Shape.\nband!(lower, upper, args...; kwargs...) draws a ribbon or band between lower and upper. These are either containers of (x,y) points or functions, in which case args... is read as a, b, n = 251 to specify a range of values to plot over. The function can be scalar valued or parameterizations of a space curve in 2 or 3 dimensions. The ribbon argument of Plots is not supported.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"There are just mutating versions of the above.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"In addition, there are a few, simple, non-polygonal shapes, including lines:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"hline!(y; xmin=0.0, xmax=1.0) draws a horizontal line at elevation y across the computed axis, or adjusted via xmin and xmax.  The extrema function computes the axis sizes. If y is a container, multiple lines are drawn.\nvline(x; ymin=0.0, ymax=1.0)  draws a vertical line at  x across the computed axis, or adjusted via ymin and ymax. The extrema function computes the axis sizes. If x is a container, multiple lines are drawn.\nabline!(intercept, slope) for drawing lines a + bx in the current frame.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"(There are also Shape(:hline) and Shape(:vline) that can be used, though typically would require some translation and scaling.)","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"For example, this shows how one could visualize the points chosen in a plot, showcasing both plot and scatter! in addition to a few other plotting commands:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"f(x) = x^2 * (108 - 2x^2)/4x\nx, y = BinderPlots.unzip(f, 0, sqrt(108/2))\nplot(x, y; legend=false)\nscatter!(x, y, markersize=10)\n\nquiver!([2,4.3,6],[10,50,10], [\"sparse\",\"concentrated\",\"sparse\"],\n        quiver=([-1,0,1/2],[10,15,5]))\n\n# add rectangles to emphasize plot regions\ny0, y1 = extrema(current()).y  # get extent in `y` direction\nrect!(0, 2.5, y0, y1, fillcolor=\"#d3d3d3\", fillalpha=0.2)\nrect!(2.5, 6, y0, y1, linecolor=\"black\", fill=(\"orange\", 0.2))\nx1 = last(x)\nrect!(6, x1, y0, y1, fillcolor=rgb(150,150,150), opacity=0.2)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The values returned by BinderPlots.unzip(f, a, b) are not uniformly chosen, rather where there is more curvature there is more sampling. For illustration purposes, this is emphasized in a few ways: using quiver! to add labeled arrows and rect! to add rectangular shapes with transparent filling.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"As seen in this overblown example, there are other methods besides plot for other useful tasks. These include:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"scatter! is used to plot points using markers.\nquiver! is used to add arrows to a plot. These can optionally have their tails labeled, so this method can be repurposed to add annotations.  The quiver command allows for text rotation. Also arrow and arrows for different interfaces for drawing arrows. The annotate! function is used to add annotations at a given point. There are keyword arguments to adjust the text size, color, font-family, etc.\nrect! is used to make a rectangle. There are also hspan! and vspan!. For lines, there are hline! and vline! to draw horizontal or vertical lines across the extent of the plotting region. There is also abline! to draw lines specified in intercept-slope form across the extent of the plotting region. Other regions can be draws. For example, circle! to draw a circle, and, more generally, poly can be used to draw a polygonal region.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"For another example, shapes can be used to create error bars. For example, suppose at a pair of points, error bars with width sigma are to be drawn:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"import BinderPlots: translate, scale\nxs = 1:5\nys = [1,3,2,4,5]\nsigmas = 1 ./ (1:5)\n\nscatter(xs, ys, markersize=5)\n\nvl = Shape(:vline)\nerrors = [translate(scale(vl, 1, σ), x, y) for (σ, x,y) in zip(sigmas, xs, ys)]\nplot!(errors; fill=(stroke(2),) )\n\nto_documenter(current())           # hide","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"To adjust the width of the bar, we pass the value through stroke. Error bars can be added with the series type :xerror, as with plot!(xs, ys; seriestype=[:xerror], xerror=(1 ./ (1:5), )).","category":"page"},{"location":"basic-graphics/#Attributes","page":"Basics","title":"Attributes","text":"","category":"section"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Attributes of a plot are modified through keyword arguments. The Plots.jl interface allows many aliases and has magic arguments. No attempt to cover all of these is made.","category":"page"},{"location":"basic-graphics/#Keyword-arguments","page":"Basics","title":"Keyword arguments","text":"","category":"section"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The are several keyword arguments used to adjust the defaults for the graphic, for example, legend=false and markersize=10. Some keyword names utilize Plots.jl naming conventions and are translated back to their Plotly counterparts. Additional keywords are passed as is, so should use the Plotly names.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Some keywords chosen to mirror Plots.jl are:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Argument Used by Notes\nsize=(width=..., height=...) new plot calls set figure size, cf. size! with named tuple; alias windowsize\nxlims, ylims new plot calls set figure boundaries, cf xlims!, ylims!, extrema\nlegend new plot calls set or disable legend\naspect_ratio new plot calls set to :equal for equal x-y (and z) axes\nlabel plot, plot! set with a name for trace in legend\nlinecolor plot, plot! set with a color; alias lc\nlinealpha plot, plot! set with a value in (0,1)\nlinewidth plot, plot! set with an integer; aliases lw, width\nlinestyle plot, plot! set with \"solid\", \"dot\", \"dash\", \"dotdash\", ...; aliases style, ls\nlineshape plot, plot! set with \"linear\", \"hv\", \"vh\", \"hvh\", \"vhv\", \"spline\"; from plotly\nline plot, plot! set with tuple of magic line arguments\nmarkershape scatter, scatter! set with \"diamond\", \"circle\", ...; alias shape\nmarkersize scatter, scatter! set with integer; alias ms\nmarkercolor scatter, scatter! set with color; alias mc\nmarkeralpha scatter, scatter! set with a value in (0,1)\nmarker scatter, scatter! set with tuple of magic marker arguments\nfillcolor shapes interior color of a 2D shape; alias fc\nfillalpha shapes set with a value in (0,1)\nfillrange shapes how much to fill\nfill shapes set with magic fill arguments\ncolor annotate! set with color argument of text\nfamily annotate! set with string (font family)\npointsize annotate! set with integer\nrotation annotate! set with angle, degrees, real\ncenter new 3d plots set with tuple, see controls\nup new 3d plots set with tuple, see controls\neye new 3d plots set with tuple, see controls","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"As seen in the example there are many ways to specify a color. These can be by name (as a symbol or as a string),  using HEX colors (as strings), using rgb. (The rgb function, unlike the standard Colors.RGB, uses values in 0 to 255 to specify the values and also can take a fourth argument for an alpha value, which is useful for filling with opacity.)","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Some exported names are used to adjust a plot after construction:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"title!, xlabel!, ylabel!, zlabel!: to adjust title; x-axis label; y-axis label\nxlims!, ylims!, zlims!: to adjust limits of viewing window\nxticks!, yticks!, zticks!: to adjust axis ticks\nxaxis!, yaxis!, zaxis!: to adjust the axis properties","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"note: Subject to change\nThere are some names for keyword arguments that should be changed.","category":"page"},{"location":"basic-graphics/#\"Magic\"-arguments","page":"Basics","title":"\"Magic\" arguments","text":"","category":"section"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The designer of Plots.jl cleverly recognized that many argument types come in similar groups. For example, lines, markers, and filling all have a color and an alpha transparency level. Each may have a different style or shape. Each may have a different scale. Moreover, scales are described by integers, styles described by symbols or strings, colors by symbols or strings – if not a more specific type –  and transparencies by a number in (01). As Julia can readily dispatch on value types, an expression like (:red, 0.25, 12) can be  parsed to identify a color, an alpha level and a scale. From here, it was a smart move to use keywords, like line and fill, to associate these values with different attribute groups.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The Plots.jl design leverages data types to \"magically\" fill in keyword arguments. Much of this is implemented within BinderPlots, as described next.","category":"page"},{"location":"basic-graphics/#Series-arguments","page":"Basics","title":"Series arguments","text":"","category":"section"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The special keyword arguments line, marker, and fill are iterated over to fill in keyword arguments. For example, passing line=(5, (:red, :blue), 0.25, :dash) will specify: Draw all lines with width 5, linealpha=0.25, and use dashes, not solid lines, for the line style. For any odd number series the line color will be rgb(:red, 0.25); even numbered series (when present) will have color rgb(:blue, 0.25), as the values passed to line are recycled when there are multiple series specified.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The container passed to line has the following mappings:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"symbols and strings are matched against the possible linestyles, then the possible lineshapes; if there is no match, then the value is assumed to specify a color\na number in (0,1) indicates a transparency level\nan integer specifies the scale for the line width\nrgb values are passed to the linecolor attribute\na Stroke object, produced by stroke, can alternatively be used to specify these values","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The container passed to marker has the following mappings:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"symbols and strings are matched against known marker shapes; if there is no match then the value is assumed to specify a color\nscale, color, and transparency are as for line","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The container passed to fill has the following mappings:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"symbols and strings are matched against fill styles; if there is no match then the value is assumed to specify a color\na number in (0,1) indicates a transparency level\na 0 sets fill style = :tozeroy. (Other integers are not available, as in Plots.jl)\na true indicates the fill style should be :toself\nStroke objects, produced by stroke, adjust the properties of the line","category":"page"},{"location":"basic-graphics/#Other-uses-of-magic-arguments","page":"Basics","title":"Other uses of magic arguments","text":"","category":"section"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The font function (which can be called directly or indirectly through text or annotate!) has the following magic arguments defined:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"strings are assumed to indicate font families\nsymbols are checked for alignment (e.g., :top, :bottom, etc.); if no match, they are assumed to be a color specification.\nintegers specify point sizes\nnon integers (e.g. pi/4) indicate rotation","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The legend argument can be a boolean or a container. When a container the values are magically transformed with:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"symbols are checked for correspondence with a legend position; if the symbol is :reverse, otherwise the symbol is assumed to be a color specification.\ntuples indicate the placement position\nFont instances, as produced by font, indicate the font in the legend\nBoolean values indicate whether to show or hide the legend","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The [xyz]axis! function arguments have:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Symbols are checked for scale indicators (:log, :linear, :log2m :log10, :flip, :invert, :inverted)\nstrings and Text values are applied to the axis label.\ntuples are assumed to indicate a range if length 2, otherwise a collection of tick placements.\nFont values apply to the tick fonts\nBoolean values indicate if the grid should be shown for that axis","category":"page"},{"location":"basic-graphics/#Example","page":"Basics","title":"Example","text":"","category":"section"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"This example is from the section on \"Input Data\" from the Plots.jl documentation. It use shapes and other objects to draw a Batman scene. We recreate it here to illustrate some small but significant differences between Plots.jl and BinderPlots. The comments with superscripts are where differences are needed:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"using BinderPlots\nimport BinderPlots: translate, stroke, BezierCurve #¹\n\nconst Plots = BinderPlots\nRGB(a,b,c) = rgb(round.(Int, 255 .* (a,b,c))...) #²\nconst plot_color = rgb\n\nfunction make_batman()\n    p = [(0, 0), (0.5, 0.2), (1, 0), (1, 2),  (0.3, 1.2), (0.2, 2), (0, 1.7)]\n    s = [(0.2, 1), (0.4, 1), (2, 0), (0.5, -0.6), (0, 0), (0, -0.15)]\n    m = [(p[i] .+ p[i + 1]) ./ 2 .+ s[i] for i in 1:length(p) - 1]\n\n    pts = similar(m, 0)\n    for (i, mi) in enumerate(m)\n        append!(\n            pts,\n            map(BezierCurve([p[i], m[i], p[i + 1]]), range(0, 1, length = 30))\n        )\n    end\n    x, y = Plots.unzip(Tuple.(pts))\n    Shape(vcat(x, -reverse(x)), vcat(y, reverse(y)))\nend\n\n# background and limits\nplt = plot(\n    bg = :black,\n    xlim = (0.1, 0.9),\n    ylim = (0.2, 1.5),\n    framestyle = :none,\n    size = (400, 400),\n    legend = false,\n)\n\nxaxis!(plt; showticklabels = false, showgrid = false, zeroline = false) #³\nyaxis!(plt; showticklabels = false, showgrid = false, zeroline = false) #³\n\n\n\n# create an ellipse in the sky\npts = Plots.partialcircle(0, 2π, 100, 0.1)\nx, y = Plots.unzip(pts)\nx = 1.5x .+ 0.7\ny .+= 1.3\npts = collect(zip(x, y))\n\n# beam\nbeam = Shape([(0.3, 0.0), pts[95], pts[50], (0.3, 0.0)])\nplot!(beam, fillcolor = plot_color(:yellow, 0.3))\n\n# spotlight\n# plot!(Shape(x, y), c = :yellow)  #⁴ no seriescolor argument\nplot!(Shape(x, y), fc = :yellow)\n\n# buildings\nrect(w, h, x, y) = Shape(x .+ [0, w, w, 0, 0], y .+ [0, 0, h, h, 0])\ngray(pct) = RGB(pct, pct, pct)\nfunction windowrange(dim, denom)\n    range(0, 1, length = max(3, round(Int, dim/denom)))[2:end - 1]\nend\n\nfor k in 1:50\n    local w, h, x, y = 0.1rand() + 0.05, 0.8rand() + 0.3, rand(), 0.0\n    shape = rect(w, h, x, y)\n    graypct = 0.3rand() + 0.3\n    plot!(shape, fc = gray(graypct))  #⁴\n\n    # windows\n    I = windowrange(w, 0.015)\n    J = windowrange(h, 0.04)\n    local pts = vec([(Float64(x + w * i), Float64(y + h * j)) for i in I, j in J])\n\n    windowcolors = Symbol[rand() < 0.2 ? :yellow : :black for i in 1:length(pts)]\n    local xs, ys = BinderPlots.unzip(pts)\n    scatter!(xs', ys', marker = (stroke(0), :square, windowcolors)) #⁵\n\n\nend\nplt\n\nbatman = Plots.scale(make_batman(), 0.07, 0.07, (0, 0))\nbatman = translate(batman, 0.7, 1.23)\nplot!(batman, fillcolor = :black)\n\nto_documenter(current())           # hide","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"To remark on the differences:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The translate and scale methods for Shape instances and the BezierCurve constructor (lifted directly for Plots.jl) are not exported.\nthe use of RGB from Colors.jl is not supported in PlotlyLight and hence BinderPlots. The rgb function is a replacement which also replaces the plot_color function used above to add an alpha transparency to a color specified by a symbol.\nThe illustrated use of xaxis! and yaxis! is needed to make a blank canvas. There is also an unexported blank_canvas function to avoid this detail.\nThere is no support for the seriescolor argument (with the c alias). Rather the fill color is needed to be specified in this line.\nThe Plots.jl interface allows individual points in a scatter plot to have colors specified, so scatter!(pts, ...) works, where the values specified to marker are recycled. However, this is not the case with","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"the BinderPlots interface which specifies these colors at the series level. In the above, taking the adjoint of the x- and y-values creates an abstract matrix, and then each column is taken as specifying a different series. Alternatively, two series could be used to paint the windows black or yellow. For example:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"inds = [rand() < 0.2 for i in 1:length(pts)]\nscatter!(BinderPlots.Series(pts[inds], pts[.!inds]), marker=(stroke(0), :square, (:yellow,:black)))","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Also, the shape :square is used, not :rect, as in the original, for this is not a supported shape in Plotly.","category":"page"},{"location":"basic-graphics/#Currently-unsupported","page":"Basics","title":"Currently unsupported","text":"","category":"section"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The last example highlighted a few differences between Plots.jl and less featureful BinderPlots.jl. In addition to a less relaxed method for data specification, a few other important differences are summarized in the following (with order given by failing examples from the examples.jl file):","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Some markers are not supported, and if passed as a magic argument will be identified as a color (e.g., :hex,:d, :rect, ...)\nSeveral shorthands are not defined (e.g. histogram, histogram2d, bar, OHLC, pie, boxplot, violin, spy, portfoliocomposition, areaplot, curves)","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The seriestype might be defined. If not, defining a method for SeriesType, like SeriesType(::Val{:histogram}) = (:histogram, :histogram) where the return lists a type and a mode value for plotly, may work.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The @layout macro is not supported","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The only grid layout is to put the plots into an array, one plot per cell. For side-by-side plots, plot(p1, p2, ...) is supported.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"A PR would be most welcome.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Shapes can not be used as custom  markers","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Plots.jl allows custom shapes as markers. This is not supported, though can be mimicked, as in the following:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"s = Shape(:star6)\nBinderPlots.scale!(s, 1/20) # shape is roughly unit circle size\nxs, ys = rand(50), rand(50)\n\nBinderPlots.blank_canvas(xlims=(0,1), ylims=(0,1),\n    aspect_ratio=:equal)\nplot!([BinderPlots.translate(s, x, y) for (x,y) in zip(xs,ys)],\n             fill=(:yellow, clamp.(rand(50), 0.5, 1), BinderPlots.stroke(:black)),\n\t\t\t bg=:black)\n\n\nto_documenter(current())           # hide","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"There is no @df macro, no group argument\nThe projection keyword is not supported for polar maps\nPlotsMeasures are not supported\nAnimations are not supported\nmagic grid arguments are not supported\nThe ribbon argument is not supported in the same manner","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"Ribbons must be specified with the seriestype :ribbon. The band function may be a substitute.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The lens feature is not supported\nThe default function is not supported\nlinked axes are not supported\nMesh3d support is lacking\nseriestype is slightly different","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"In Plots.jl it can modify how a line is drawn, use linestyle for that instead.","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"guides are not supported\nflipping of axes is note supported\nhspan! and vspan! have different calling styles; there are no hspan or vspan methods\nThere are no annotations at discrete locations, only at points\nproj_type is not supported; camera is idiosyncratic\nBezier curves are a bit more cumbersome than calling curves","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"The curves function might be replicated by:","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"function curves(x, y; kwargs...)\n   BC = BinderPlots.BezierCurve(tuple.(x,y))\n   plot(t -> BC(t), 0, 1; kwargs...)\n   scatter!(BC.control_points, marker=(12, 0.75))\nend\ncurves(1:4, [1,1,2,4]; title=\"Bezier Curve\")\n\nto_documenter(current())           # hide","category":"page"},{"location":"basic-graphics/","page":"Basics","title":"Basics","text":"There is no hatching for fill style\nShared axes (twinx) are not supported\nlegend positioning is different","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"Modules = [BinderPlots]","category":"page"},{"location":"reference/#BinderPlots.BinderPlots","page":"Reference/API","title":"BinderPlots.BinderPlots","text":"BinderPlots is a lightweight interface to the underlying PlotlyLight package (Fastest time-to-first-plot in Julia!), itself an \"ultra-lightweight interface\" to the Plotly javascript libraries. BinderPlots supports some of the Plots.jl interface for plotting. This package may be of use as an alternative to Plots in resource-constrained environments, such as binder.\n\nPlots.jl uses\n\npositional arguments for data\nkeyword arguments for attributes\nplot() is a workhorse with seriestype indicating which plot; there are also special methods (e.g. scatter(x,y) becomes plot(x,y; seriestype=\"scatter\"))\n\nPlotlyLight.jl uses\n\ndata::Vector{Config} to hold tracts of data for plotting\nlayout::Config to adjust layout\nconfig::Config to adjust global configurations\nConfig very flexibly creates the underlying Javascript objects the plotly interface expects\nPlot() is a workhorse with type acting like seriestype and also mode\n\nBinderPlots.jl has this dispatch for plot:\n\nLine plot. connecting x,y (and possibly z). For 2D, use !isfinite values in y to break.\n\nplot(x,y,[z]; kwargs...)\nplot!([p::Plot], x, y, [z]; kwargs...)\nplot(pts; kwargs...)\nplot!([p::Plot], pts; kwargs...)\n\nData can be generated from a function:\n\nplot(f::Function, ab; kwargs...) => plot(unzip(f, ab)...; kwargs...)\nplot(f::Function, a, b; kwargs...) => plot(unzip(f, a, b)...; kwargs...)\nplot!([p::Plot], f, ab, [b])\n\nplot each function as lineplot:\n\nplot(fs::Vector{Function}, a, [b]; kwargs...)\nplot!([p::Plot], fs::Vector{Function}, a, [b]; kwargs...)\n\nnote: Note\nCurrently x, y make vectors; should matrices be supported using column vectors? \"In Plots.jl, every column is a series, a set of related points which form lines, surfaces, or other plotting primitives. \"\n\nParametric line plots, 2 or 3d\n\nplot(fs::NTuple(N,Function), a, [b]; kwargs...)\nplot!([p::Plot], fs::NTuple(N,Function), a, [b]; kwargs...)\n\nAlternatively\n\nplot(u::Function, v::Function, [w::Function], a, [b]; kwargs...)\n\nThe plot interface of PlotlyLight: merge layout; merge config; pass kwargs to Config push onto data or merge onto last tract:\n\nplot(; layout::Config?, config::Config, kwargs...)\nplot!([p::Plot]; layout::Config?, config::Config?, kwargs...)\n\nThis interface can be used to generate other plot types either by specifying the type argument, or using the form plot.plot_type(...), as with plot.scatter(x, y).\n\nThe plot function primarily plots line plots where the specified points are connected with lines (when finite); The scatter function plots just the points.\n\nIn addition there are these plot constructors for higher-dimensional plots\n\ncontour\nplot_implicit\nheatmap\nsurface\nwireframe\n\nThere are also numerous functions to modify attributes of an existing plot.\n\n\n\n\n\n","category":"module"},{"location":"reference/#BinderPlots.BezierCurve","page":"Reference/API","title":"BinderPlots.BezierCurve","text":"create a BezierCurve for plotting\n\nFrom Plots.jl\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinderPlots.Series","page":"Reference/API","title":"BinderPlots.Series","text":"Series(xs₁, xs₂, …)\n\nStruct to indicate traces in a series. Can be used in place of matrix to combine mismatched sizes, e.g.\n\nscatter(BinderPlots.Series(1:3, 1:5), markersize=(20,10))\n\nNot exported.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinderPlots.Shape","page":"Reference/API","title":"BinderPlots.Shape","text":"Shape(x, y)\nShape(vertices)\n\nConstruct a polygon to be plotted.\n\nWhen plotting shapes, use stroke argument to fill to adjust bounding line properties.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinderPlots.SeriesType-Tuple{Symbol}","page":"Reference/API","title":"BinderPlots.SeriesType","text":"SeriesType(x::Symbol)\n\nReturn a type and mode for plotly based on a Plots.jl series type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.abline!-Tuple{Any, Any}","page":"Reference/API","title":"BinderPlots.abline!","text":"abline!([p::Plot], intercept, slope; kwargs...)\n\nDraw line y = a + bx over current viewing window, as determined by extrema(p).\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.annotate!-Tuple{Plot, Any, Any, Any}","page":"Reference/API","title":"BinderPlots.annotate!","text":"annotate!([p::Plot], x, y, txt; [color], [family], [pointsize], [halign], [valign])\nannotate!([p::Plot], anns::Tuple;  kwargs...)\n\nAdd annotations to plot.\n\nx, y, txt: text to add at (x,y)\ncolor: text color\nfamily: font family\npointsize: text size\nhalign: one of \"top\", \"bottom\"\nvalign: one of \"left\", \"right\"\nrotation: angle to rotate\n\nThe x, y, txt values can be specified as 3 iterables or tuple of tuples.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.arrow-Tuple{Any, Any}","page":"Reference/API","title":"BinderPlots.arrow","text":"arrow(tails, vs; kwargs...)\n\nDraw vectors vs anchored at tails. Hacked in support for 3D using combination of lines + cones.\n\nUse Plotly attributes arrowcolor, arrowwidth,\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.arrows-Tuple{Any, Any, Function}","page":"Reference/API","title":"BinderPlots.arrows","text":"arrows(x, y, [z], f::Function; kwargs...)\narrows(x, y, [z], u, v, [w]; kwargs...)\narrows!([p::Plot], x, y, [z], f::Function; kwargs...)\narrows!([p::Plot], x, y, [z], u, v, [w]; kwargs...)\n\nDraw arrows from x-y-[z] with lengths u-v-w (or optionally generated by f).\n\nExample\n\nplot(;xlims=(-5,5), ylims=(-5,5))\nf(x,y) = (-y,x)./sqrt(1 + x^2 + y^2)\ngrid = tuple.((-5:5)', (-5:5))\narrows!(unzip(grid)..., f)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.band-Tuple{Any, Any, Vararg{Any}}","page":"Reference/API","title":"BinderPlots.band","text":"band(lower, upper; kwargs...)\nband(lower::Function, upper::Function, a::Real, b::Real,n=251; kwargs...)\nband!([p::Plot],lower, upper; kwargs...)\nband!([p::Plot],lower::Function, upper::Function, a::Real, b::Real,n=251; kwargs...)\n\nDraw band between lower and upper. These may be specified by functions or by tuples of x-y-[z] values.\n\nExample\n\nUsing (x,y) points to define the boundaries\n\nxs = 1:0.2:10\nys_low = -0.2 .* sin.(xs) .- 0.25\nys_high = 0.2 .* sin.(xs) .+ 0.25\n\np = plot(;xlims=(0,10), ylims=(-1.5, .5), legend=false)\nband!(zip(xs, ys_low), zip(xs, ys_high); fillcolor=:blue)\nband!(zip(xs, ys_low .- 1), zip(xs, ys_high .- 1); fillcolor=:red)\n\nOr, using functions to define the boundaries\n\nband(x -> -0.2 * sin(x) - 0.25, x -> 0.2 * sin(x) + 0.25,\n     0, 10;  # a, b, n=251\n     fillcolor=:red, legend=false)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.center-Tuple{Shape}","page":"Reference/API","title":"BinderPlots.center","text":"return the centroid of a Shape\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.circ3d-Tuple{Any, Any, Any}","page":"Reference/API","title":"BinderPlots.circ3d","text":"circ3d(q, r, n̄; kwargs...)\ncirc3d!([p::Plot], q, r, n̄; kwargs...)\n\nPlot circle in 3 dimensions with center at q, radius r, and perpendicular to normal vector n̄.\n\nExample\n\nq, n = [0,0,0], [0,0,1]\ncirc3d(q, 3, n)\narrow!(q, n)\n\nOr a more complicated one:\n\nZ(r, θ) = 4 - r\nX(r, θ) = r * cos(θ)\nY(r, θ) = r * sin(θ)\nrs = range(0,4, length=10)\nθs = range(0, 2pi, length=100)\nsurface(X.(rs', θs), Y.(rs', θs), Z.(rs', θs); opacity=0.25)\nq = [0,0,2]\nn = [0,0,1]\nr = 2\ncirc3d!(q, r, n; color=\"black\", opacity=0.75)\nq, v̂, ŵ = [0,0,0], [0,4,0], [0,0,4]\nparallelogram!(q, v̂, ŵ; opacity=0.5, color=:yellow)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.circle!-Tuple{Plot, Vararg{Any, 4}}","page":"Reference/API","title":"BinderPlots.circle!","text":"circle([p::Plot], x0, x1, y0, y1; kwargs...)\n\nDraw circle shape bounded in [x0, x1] × [y0, y1]. (Will adjust to non-equal sized boundary.)\n\nExample\n\nUse named tuple for line for boundary.\n\ncircle!(p, 2,3,-1,1; line=(color=:gray,), fillcolor=:red, opacity=0.2)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.contour-Tuple","page":"Reference/API","title":"BinderPlots.contour","text":"contour(x, y, z; kwargs...)\ncontour!([p::Plot], x, y, z; kwargs...)\ncontour(x, y, f::Function; kwargs...)\ncontour!(x, y, f::Function; kwargs...)\n\nCreate contour map.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.current-Tuple{}","page":"Reference/API","title":"BinderPlots.current","text":"current()\n\nGet current figure. A Plot object of PlotlyLight; UndefRefError if none.\n\nNot typically needed, as it is implicit in most mutating calls, though may be convenient if those happen within a loop.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.font-Tuple{BinderPlots.Font}","page":"Reference/API","title":"BinderPlots.font","text":"font(args...)\n\n(This is from Plots.jl)\n\nCreate a Font from a list of features. Values may be specified either as arguments (which are distinguished by type/value) or as keyword arguments.\n\nArguments\n\nfamily: AbstractString. \"serif\" or \"sans-serif\" or \"monospace\"\npointsize: Integer. Size of font in points\nhalign: Symbol. Horizontal alignment (:hcenter, :left, or :right)\nvalign: Symbol. Vertical alignment (:vcenter, :top, or :bottom)\nrotation: Real. Angle of rotation for text in degrees (use a non-integer type). (Works with ticks and annotations.)\ncolor\n\nExamples\n\njulia> font(8)\njulia> font(family=\"serif\", halign=:center, rotation=45.0)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.grid_layout-Tuple{Array{<:Plot}}","page":"Reference/API","title":"BinderPlots.grid_layout","text":"grid_layout(ps::Array{<:Plot})\n\nLayout an array of plots into a grid. Vectors become rows of plots.\n\nUse Plot() to create an empty plot for a given cell.\n\nExample\n\nusing DataFrames\nn = 25\nd = DataFrame(x=sin.(rand(n)), y=rand(n).^2, z = rand(n)) # assume all numeric\nnms = names(d)\nm = Matrix{Plot}(undef, length(nms), length(nms))\n\nfor i ∈ eachindex(nms)\n    for j ∈ eachindex(nms)\n        if j > i\n            p = Plot()\n        elseif j == i\n            x = d[:,j]\n            p = plot(x, seriestype=:histogram)\n            xlabel!(p, nms[j])  # <<- not working in grid! as differe xaxis purposes\n        else\n            x = d[:,i]; y = d[:,j]\n            p = scatter(x, y)\n            xlabel!(p, nms[i]); ylabel!(p, nms[j])\n        end\n        m[i,j] = p\n    end\nend\nplot(m)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.heatmap-Tuple","page":"Reference/API","title":"BinderPlots.heatmap","text":"heatmap(x, y, z; kwargs...)\nheatmap!([p::Plot], x, y, z; kwargs...)\nheatmap(x, y, f::Function; kwargs...)\nheatmap!(x, y, f::Function; kwargs...)\n\nCreate heatmap function of f\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.hline!-Tuple{Any}","page":"Reference/API","title":"BinderPlots.hline!","text":"hline!(y; xmin=0, xmax=1.0; kwargs...)\n\nDraw horizontal line at y. By default extends over the current plot range, this can be adjusted by xmin and xmax, values in [0,1].\n\nThe values for y, xmin, and xmax are broadcast.\n\nA current plot must be made to add to, as the extent of the lines is taken from the current plot.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.hspan!-Tuple{Any, Any}","page":"Reference/API","title":"BinderPlots.hspan!","text":"hspan!([p::Plot], ys; kwargs...)\nhspan!([p::Plot], ys, YS; xmin=0.0, ymin=1.0, kwargs...)\n\nDraw horizontal rectanglular rectangle from ys to YS. By default extends over x range of plot p, though using xmin or xmax can adjust that. These are values in [0,1] and are interpreted relative to the range returned by extrema(p).x.\n\nIf just ys is specified, it is taken as zipped form of (ys, YS). This form is from Plots.jl so use this for compatibility.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.image!-Tuple{Any}","page":"Reference/API","title":"BinderPlots.image!","text":"image!([p::Plot], img_url; [x],[y],[sizex],[sizey], kwargs...)\n\nPlot image, by url, onto background of plot.\n\nx,y,sizex, sizey specify extent via [x, x+sizex] × [y-sizey, y].\npass sizing=\"stretch\" to fill space.\nother arguments cf. plotly examples.\n\nExample\n\nimg = \"https://upload.wikimedia.org/wikipedia/commons/thumb/1/1f/Julia_Programming_Language_Logo.svg/320px-Julia_Programming_Language_Logo.svg.png\"\nplot(;xlims=(0,1), ylims=(0,1), legend=false);\nimage!(img; sizing=\"stretch\")\nplot!(x -> x^2; linewidth=10, linecolor=:black)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.legend!-Tuple{Plot, Nothing}","page":"Reference/API","title":"BinderPlots.legend!","text":"legend!([p::Plot], legend::Bool) hide/show legend\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.parallelogram-Tuple{Any, Any, Any}","page":"Reference/API","title":"BinderPlots.parallelogram","text":"parallelogram(q, v̄, w̄; kwargs...)\nparallelogram!([p::Plot], q, v̄, w̄; kwargs...)\n\nPlot parallelogram formed by two vectors, v̄ and w̄, both anchored at point q.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.plot!-Tuple","page":"Reference/API","title":"BinderPlots.plot!","text":"plot!([p::Plot], x, y; kwargs...)\nplot!([p::Plot], f, a, [b]; kwargs...)\nplot!([p::Plot], f; kwargs...)\n\nUsed to add a new trace to an existing plot. Like Plots.plot!. See plot for argument details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.plot-Tuple","page":"Reference/API","title":"BinderPlots.plot","text":"plot(x, y, [z]; kwargs...)\nplot(f::Function, a, [b]; kwargs...)\nplot(pts; kwargs...)\nplot(x,[y],[z]; seriestype::Symbol=:lines, kwargs...)\n\nCreate a plot, defaulting to a line plot.\n\nReturns a Plot instance from PlotlyLight\n\nFor lines:\n\nx,y,[z] points to plot. NaN values break the line. Can be specified through a container, pts of (xy) or (xyz) values.\na, b: the interval to plot a function over can be given by two numbers or if just a then by extrema(a).\nlabel in legend\nlinecolor: color of line\nlinewidth: width of line\n\nThe line argument allows for magic arguments.\n\nOther keyword arguments include size=(width=X, height=Y), xlims and ylims, legend, aspect_ratio.\n\nProvides an interface like Plots.plot for plotting a function f using PlotlyLight. This just scratches the surface, but PlotlyLight allows full access to the underlying JavaScript library library.\n\nThe provided \"Plots-like\" functions are plot, plot!, scatter!, scatter, annotate!,  title!, xlims! and ylims!.\n\nExample\n\np = plot(sin, 0, 2pi; legend=false)\nplot!(cos)\n# add points\nx0 = [pi/4, 5pi/4]\nscatter!(x0, sin.(x0), markersize=10)\n# add text\nannotate!(tuple(zip(x0, sin.(x0), (text(\"A\",:top), text(\"B\",:top)))...), halign=\"left\", pointsize=12)\ntitle!(\"Sine and cosine and where they intersect in [0,2π]\")\n# adjust limits\nylims!((-3/2, 3/2))\n# add shape\ny0, y1 = extrema(p).y\n[rect!(xᵢ-0.1, xᵢ+0.1, y0, y1, fillcolor=\"gray\", opacity=0.2) for xᵢ ∈ x0]\n# display plot\np\n\nnote: Warning\nYou may need to run the first plot cell twice to see an image.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.plot_implicit-Tuple{Function}","page":"Reference/API","title":"BinderPlots.plot_implicit","text":"plot_implicit(f; xlims=(-5,5), ylims=(-5,5), legend=false, linewidth=2, kwargs...)\nplot_implicit!([p::Plot], f; kwargs...)\n\nFor f(x,y) = ... plot implicitly defined y(x) from f(x,y(x)) = 0 over range specified by xlims and ylims.\n\nExample\n\nf(x,y) = x * y - (x^3 + x^2 + x + 1)\nplot_implicit(f)\n\n(Basically just contour plot with levels=0 and points determined by extrema of xlims and ylims.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.poly-Tuple{Any}","page":"Reference/API","title":"BinderPlots.poly","text":"poly(points; kwargs...)\npoly!([p::Plot], points; kwargs...)\n\nPlot polygon described by points, a container of x-y or x-y-z values. Alternative to creating Shape instance.\n\nExample\n\nf(r,θ) = (r*cos(θ), r*sin(θ))\npoly(f.(repeat([1,2],5), range(0, 2pi-pi/5, length=10)))\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.quiver!","page":"Reference/API","title":"BinderPlots.quiver!","text":"quiver!([p::Plot], x, y, txt=nothing; quiver=(dx, dy), kwargs...)\nquiver(x, y, txt=nothing; quiver=(dx, dy), kwargs...)\n\nDraw 2d arrows. See BinderPlots.arrow! for a single arrow.\n\n(x,y) are tail positions, optionally labeled by txt\nquiver specifies vector part of arrow\nkwargs processarrowhead::Int?,arrowwidth::Int?,arrowcolor`\n\nExample\n\nts = range(0, 2pi, length=100)\np = plot(sin.(ts), cos.(ts), linecolor=\"red\")\nts = range(0, 2pi, length=10)\nquiver!(p, cos.(ts), sin.(ts), quiver=(-sin.(ts), cos.(ts)), arrowcolor=\"red\")\np\n\nThis example shows how text can be rotated with angles in degrees and positive angles measured in a clockwise direction.\n\nts = range(0, 2pi, 100)\np = plot(cos.(ts), sin.(ts), linecolor=\"red\", aspect_ratio=:equal,\n    linewidth=20, opacity=0.2)\n\ntxt = split(\"The quick brown fox jumped over the lazy dog\")\nts = range(0, 360, length(txt)+1)[2:end]\nfor (i,t) ∈ enumerate(reverse(ts))\n    quiver!(p, [cosd(t)],[sind(t)],txt[i],\n            quiver=([0],[0]),\n            textangle=90-t,\n            font=(size=20,))\nend\nxaxis!(zeroline=false); yaxis!(zeroline=false) # remove zerolines\np\n\nnote: 3d arrows\n3d arrows are possible using arrows!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinderPlots.rect!-Tuple{Plot, Vararg{Any, 4}}","page":"Reference/API","title":"BinderPlots.rect!","text":"rect!([p::Plot], x0, x1, y0, y1; kwargs...)\n\nDraw rectangle shape on graphic.\n\nExample [2, 3] × [-1, 1]\n\nrect!(p, 2, 3, -1, 1; linecolor=:gray, fillcolor=:red, opacity=0.2)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.rgb","page":"Reference/API","title":"BinderPlots.rgb","text":"rgb(r,g,b,α=1.0)\nrgb(c::Union{RGB, RGBA}) # RGB[A] from Colors.jl\nrgb(::Symbol, α)\ncolormap(cname, N; kwargs...)\n\nSpecify red, green, blue values between 0 and 255 (as integers). The transparency is specified by the 4th argument, a value in [0.0,1.0].\n\nThe range operator can be used with color to produce a sequence, following Colors.range for RGB[A] values. (It is not lazy, so don't take length to be too large.)\n\nThe colormap function returns a colormap of length 10 using Colors.colormap.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinderPlots.rotate","page":"Reference/API","title":"BinderPlots.rotate","text":"rotate(s::Shape, θ, c=center(s))\nrotate!(s::Shape, θ, c=center(s))\n\nRotate shape about its center ccw by angle θ\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinderPlots.scale","page":"Reference/API","title":"BinderPlots.scale","text":"scale(s::Shape, x, y=x)\nscale!(s::Shape, x, y=x)\n\nScale in x and y direction\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinderPlots.scatter!-Tuple","page":"Reference/API","title":"BinderPlots.scatter!","text":"scatter!([p::Plot], x, y, [z]; kwargs...)\nscatter!([p::Plot], pts; kwargs...)\n\nAdd points to a plot.\n\nmarkershape: shape, e.g. \"diamond\" or \"diamond-open\"\nmarkercolor: color e.g. \"red\"\nmarkersize:  size, as an integer\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.scatter-Tuple","page":"Reference/API","title":"BinderPlots.scatter","text":"scatter(x, y, [z]; [markershape], [markercolor], [markersize], kwargs...)\nscatter(pts; kwargs...)\nscatter!([p::Plot], x, y, [z]; kwargs...)\nscatter!([p::Plot], pts; kwargs...)\n\nPlace points on a plot.\n\nmarkershape: shape, e.g. \"diamond\" or \"diamond-open\"\nmarkercolor: color e.g. \"red\", or :blue, or \"rgba(255, 0, 0, 0.5)\" (a string,a sit passes JavaScript command to plotly.\nmarkersize:  size, as an integer\n\nThe marker keyword has some magic arguments.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.scroll_zoom!-Tuple{Plot, Bool}","page":"Reference/API","title":"BinderPlots.scroll_zoom!","text":"scrollzoom!([p], x::Bool) turn on/off scrolling to zoom\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.size!-Tuple{Plot}","page":"Reference/API","title":"BinderPlots.size!","text":"size!([p::Plot]; [width], [height]) specify size of plot figure\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.skirt-Tuple{Any, Any, Function}","page":"Reference/API","title":"BinderPlots.skirt","text":"skirt(q, v, f::Function; kwargs...)\nskirt!([p::Plot], q, v, f::Function; kwargs...)\nskirt!([p::Plot], xs, ys, zs, f::Function; kwargs...)\n\nAlong a path (xs, ys, zs) plot a skirt between the path and (xs, ys, f(xs, ys)). The case of a path described by a vector, v, anchored at a point q has a special method.\n\nExample\n\nx(r, θ) = r*cos(θ)\ny(r, θ) = r*sin(θ)\nf(x,y) = 4 - x^2 - y^2\nrs, θs = range(0,2,length=10), range(0, 2pi, length=20)\nxs, ys = x.(rs', θs), y.(rs', θs)\nzs = f.(xs, ys)\nsurface(xs, ys, zs, opacity=.2, showscale=false)\n\nq = [0,0,0]\nv = [2,0,0]\nd = skirt!(q, v, f; opacity=0.6)\n\nt = range(0, 1, length=100)\nxs = 2 * t .* sin.(t*pi/2)\nys = 2 * t .* cos.(t*pi/2)\nzs = zero.(xs)\nskirt!(xs, ys, zs, f; color=\"blue\", opacity=0.6)\nskirt!(xs, -ys, zs, f; color=\"blue\", opacity=0.6)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.stroke-Tuple","page":"Reference/API","title":"BinderPlots.stroke","text":"stroke(args...; alpha=nothing)\n\nSpecify line attributes. Returns a Stroke instance.\n\nThis function can be used to specify the attributes of the polygonal line in a shape or other uses of lines.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.surface-Tuple","page":"Reference/API","title":"BinderPlots.surface","text":"surface(x, y, z; kwargs...)\nsurface!(x, y, z; kwargs...)\nsurface(x, y, f::Function; kwargs...)\nsurface!(x, y, f::Function; kwargs...)\n\nCreate surface plot. Pass zcontour=true to add contour plot projected onto the z axis.\n\nExample\n\nf(x,y) = 4 - x^2 - y^2\nxs = ys = range(-2, 2, length=50)\nsurface(xs, ys, f; palette=cgrad(:acton))  # zs = f.(xs', ys)\n\nExtended help\n\nFrom https://discourse.julialang.org/t/3d-surfaces-time-slider/109673\n\nz1 = Vector[[8.83, 8.89, 8.81, 8.87, 8.9, 8.87],\n                       [8.89, 8.94, 8.85, 8.94, 8.96, 8.92],\n                       [8.84, 8.9, 8.82, 8.92, 8.93, 8.91],\n                       [8.79, 8.85, 8.79, 8.9, 8.94, 8.92],\n                       [8.79, 8.88, 8.81, 8.9, 8.95, 8.92],\n                       [8.8, 8.82, 8.78, 8.91, 8.94, 8.92],\n                       [8.75, 8.78, 8.77, 8.91, 8.95, 8.92],\n                       [8.8, 8.8, 8.77, 8.91, 8.95, 8.94],\n                       [8.74, 8.81, 8.76, 8.93, 8.98, 8.99],\n                       [8.89, 8.99, 8.92, 9.1, 9.13, 9.11],\n                       [8.97, 8.97, 8.91, 9.09, 9.11, 9.11],\n                       [9.04, 9.08, 9.05, 9.25, 9.28, 9.27],\n                       [9, 9.01, 9, 9.2, 9.23, 9.2],\n                       [8.99, 8.99, 8.98, 9.18, 9.2, 9.19],\n                       [8.93, 8.97, 8.97, 9.18, 9.2, 9.18]]\nxs , ys = 1:length(z1[1]), 1:length(z1) # needed here given interface chosen\nsurface(xs, ys, z1, colorscale=\"Viridis\")\nsurface!(xs, ys, map(x -> x .+ 1, z1), colorscale=\"Viridis\", showscale=false, opacity=0.9)\nsurface!(xs, ys, map(x -> x .- 1, z1), colorscale=\"Viridis\", showscale=false, opacity=0.9)\n\nJulia users would typically use a matrix to hold the z data, but Javascript users would expect a vector of vectors, as above. As PlotlyLight just passes on the data to Javascript, the above is perfectly acceptable. Indeed BinderPlots converts matrices to this format in such plots.\n\n(The keyword arguments above come from Plotly, not Plots.)\n\nA parameterized surface can be displayed. Below the unexported unzip function returns 3 matrices specifying the surface described by the vector-valued function r.\n\nimport BinderPlots: unzip\nr1, r2 = 2, 1/2\nr(u,v) = ((r1 + r2*cos(v))*cos(u), (r1 + r2*cos(v))*sin(u), r2*sin(v))\nus = vs = range(0, 2pi, length=25)\nxs, ys, zs = unzip(us, vs, r)\n\nsurface(xs, ys, zs)\n\nPlotting a vertical plane poses a slight challenge, as we can't parameterize as z=f(x,y). Here we intersect a surface with the plane ax + by + 0z = d and add a trace for the intersection of the two surfaces.\n\nf(x, y) = 4 - (x^2 + y^2)\n\n# surface\nxs =  ys = range(-2, 2, length=100)\nzs = f.(xs', ys)\n\n# (vertical) plane\nm, M = extrema(zs)\nzzs = range(m, M, length=2)\nXs = ((x,z) -> x).(xs', zzs)\nZs = ((x,z) -> z).(xs', zzs)\na, b, c, d = 1, 1, 0, 1\nplane(x,z) = (d - a*x - c*z) / b\nYs = plane.(xs', zzs)\n\n# intersection\ny(t) = (d - a*t) / b\nγ(t) = (t, y(t), f(t, y(t)))\n\nsurface(xs, ys, zs)\nsurface!(Xs, Ys, Zs, opacity=0.2)\nplot!(unzip(γ.(xs))...; linewidth=3)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.text-Tuple{Any, Vararg{Any}}","page":"Reference/API","title":"BinderPlots.text","text":"text(str, args...; kwargs...)\ntext(str, f::Font)\n\nCreate text with font information to be passed to labeling functions.\n\nf::Font: object produced by font\nargs..., kwargs...: passed to font to create font information. The positional arguments are matched by type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.title!-Tuple{Plot, Nothing}","page":"Reference/API","title":"BinderPlots.title!","text":"title!([p::Plot], txt)\nxlabel!([p::Plot], txt)\nylabel!([p::Plot], txt)\nzlabel!([p::Plot], txt)\n\nSet plot title.\n\ntxt: either a string or a string with font information produced by text.\n\nExample\n\nf = font(20, :red, :left, :bottom, 45.0)\n\np = plot(sin, 0, 2pi)\ntitle!(p, text(\"Plot\", f))\nxlabel!(p, text(\"sine function\", f))\nxticks!(p, 0:pi:2pi, ticklabels = [\"0\", \"π\", \"2π\"], tickfont=f)\nannotate!(p, [(pi, 0, text(\"Zero\", f))])\nquiver!(p, [pi],[1/2], [text(\"zero\",f)], quiver=([0],[-1/2]))\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.translate","page":"Reference/API","title":"BinderPlots.translate","text":"translate(s::Shape, x, y=x)\ntranslate!(s::Shape, x, y=x)\n\nShift shape over by x, up by y\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinderPlots.unzip-Tuple{Any}","page":"Reference/API","title":"BinderPlots.unzip","text":"unzip(v, [vs...])\nunzip(f::Function, a, b)\nunzip(a, b, F::Function)\n\nReshape data to x,y,[z] mode.\n\nIn its basic use, zip takes two vectors, pairs them off, and returns an iterator of tuples for each pair. For unzip a vector of same-length vectors is \"unzipped\" to return two (or more) vectors.\n\nThe function version applies f to a range of points over (a,b) and then calls unzip. This uses the adapted_grid function from PlotUtils.\n\nThe function version with F computes F(a', b) and then unzips. This is used with parameterized surface plots\n\nThis uses the invert function of SplitApplyCombine.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.vline!-Tuple{Any}","page":"Reference/API","title":"BinderPlots.vline!","text":"vline!(x; ymin=0, ymax=1.0; kwargs...)\n\nDraw vertical line at x. By default extends over the current plot range, this can be adjusted by ymin and ymax, values in [0,1].\n\nThe values for x, ymin, and ymax are broadcast.\n\nA current plot must be made to add to, as the extent of the lines is taken from that.\n\nExample\n\nAdd a grid to a plot:\n\np = plot(x -> x^2, 0, 1; aspect_ratio=:equal)\nvline!(0:.1:1, linecolor=:red,  opacity=0.25, linewidth=5)\nhline!(0:.1:1, line=(:blue, 0.75))\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.vspan!-Tuple{Any, Any}","page":"Reference/API","title":"BinderPlots.vspan!","text":"vspan!([p::Plot], xs; kwargs...)\nvspan!([p::Plot], xs, XS; ymin=0.0, ymin=1.0, kwargs...)\n\nDraw vertical rectanglular rectangle from xs to XS. By default extends over y range of plot p, though using ymin or ymax can adjust that. These are values in [0,1] and are interpreted relative to the range returned by extrema(p).y.\n\nIf just xs is specified, it is taken as zipped form of (xs, XS). This form is from Plots.jl so use this for compatibility.\n\nExample\n\np = plot(x -> x^2, 0, 1; legend=false)\nM = 1 # max of function on `[a,b]`\nvspan!(0:.1:0.9, 0.1:0.1:1.0; ymax=[x^2 for x in 0:.1:0.9]/M,\n    fillcolor=:red, opacity=.25)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.wireframe-Tuple","page":"Reference/API","title":"BinderPlots.wireframe","text":"wireframe(x, y, z; kwargs...)\nwireframe(x, y, f::Function; kwargs...)\nwireframe!([p::Plot], x, y, z; kwargs...)\nwireframe!([p::Plot], x, y, f::Function; kwargs...)\n\nCreate wireframe.\n\nExample\n\nf(x, y) = 4 - x^2 - y^2\nxs = ys = range(-2, 2, length=100)\nsurface(xs, ys, f)\nwireframe!(xs, ys, f)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.xaxis!-Tuple{Plot, Vararg{Any}}","page":"Reference/API","title":"BinderPlots.xaxis!","text":"xaxis!([p::Plot]; kwargs...)\nyaxis!([p::Plot]; kwargs...)\nzaxis!([p::Plot]; kwargs...)\n\nAdjust properties of an axis on a chart using Plotly keywords.\n\nticks, ticktext, ticklen, tickwidth, tickcolor, tickfont, showticklabels\nshowgrid, gridcolor, gridwidth\nzeroline, zerolinecolor, zerolinewidth\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.xlabel!-Tuple{Plot, Nothing}","page":"Reference/API","title":"BinderPlots.xlabel!","text":"xlabel!([p::Plot], txt::Union{String, TextFont})\nylabel!([p::Plot], txt::Union{String, TextFont})\nzlabel!([p::Plot], txt::Union{String, TextFont})\n\nSet axis label. Use a text object to specify font information.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.xlims!-Tuple{Plot, Any}","page":"Reference/API","title":"BinderPlots.xlims!","text":"xlims!(p, lims) set x limits of plot\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.xticks!-Tuple{Plot, Nothing}","page":"Reference/API","title":"BinderPlots.xticks!","text":"xticks!([p::Plot], ticks; [ticklabels], [tickfont], kwargs...)\nyticks!([p::Plot], ticks; [ticklabels], [tickfont], kwargs...)\nzticks!([p::Plot], ticks; [ticklabels], [tickfont], kwargs...)\n\nSet ticks. Optionally add labels using a matching length container. Passing a Font object to tickfont will set the font.,\n\nticks: a range of collection of tick positions\nticklabels: if given, a matching length collection of strings\ntickfont: a Font instance to adjust font of all specified ticks.\nkwargs...: passed to [xyz]axis! method.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.ylims!-Tuple{Plot, Any}","page":"Reference/API","title":"BinderPlots.ylims!","text":"ylims!(p, lims) set y limits of plot\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.ziptie-NTuple{6, Any}","page":"Reference/API","title":"BinderPlots.ziptie","text":"ziptie(xs, ys, zs, xs′, ys′, zs′; kwargs...)\nziptie!([p::Plot], xs, ys, zs, xs′, ys′, zs′; kwargs...)\n\nSurface created by connecting points along two paths given by (xs, ys, zs) and (xs′, ys′, zs′). All vectors must be same length. Mesh is created by zipping together points on the two curves. Makie docs refer to this as a ruled surface.\n\nExample\n\nr(t) = (sin(t), cos(t), t)\ns(t) = (sin(t+pi), cos(t+pi), t)\nts = range(0, 4pi, length=100)\nziptie(unzip(r.(ts))..., unzip(s.(ts))...;\n       color=\"green\", opacity=.25, showscale=false)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.zlims!-Tuple{Plot, Any}","page":"Reference/API","title":"BinderPlots.zlims!","text":"zlims!(p, lims) set z limits of plot\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinderPlots.★-NTuple{4, Any}","page":"Reference/API","title":"BinderPlots.★","text":"★(q, xs, ys, zs; kwargs...)\n★!([p::Plot], q, xs, ys, zs; kwargs...)\n\nA star connected region has an origin, q, for which each boundary point (described by (xs, ys, zs) is accessible by a ray for q which does not cross the boundary.\n\nExample\n\npts = 5\nΔ = 2pi/pts/2\na, A = 1, 3\nq = [0,0,0]\nts = range(0, 2pi, length=pts+1)\nps = [(A*[cos(t),sin(t),0], a*[cos(t+Δ), sin(t+Δ), 0]) for t in ts]\nxs, ys, zs = unzip(collect(Base.Iterators.flatten(ps)))\n★(q, xs, ys, zs)\n\n\n\n\n\n","category":"method"},{"location":"three-d-graphics/#3-dimensional-graphs","page":"3D graphics","title":"3 dimensional graphs","text":"","category":"section"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"The initial graphics of calculus involve the x-y plane but eventually the visualizations require a z direction. This is because functions fR rightarrow R are graphed in x-y values, but functions such as fR^2 rightarrow R or fR rightarrow R^3 naturally use the third dimension.","category":"page"},{"location":"three-d-graphics/#Parametric-line-plots-(space-curves)","page":"3D graphics","title":"Parametric line plots (space curves)","text":"","category":"section"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"Parametric line plots show the graph of fR rightarrow R^3 by a plot linking the points (x(t) y(t) z(t)).","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"Parametric plots can be easily created by using a tuple of functions, as in:","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"using BinderPlots # load package if not loaded\nusing PlotlyDocumenter # hide\n\nversion = BinderPlots.PlotlyLight.plotly.version # hide\nPlotlyDocumenter.change_default_plotly_version(version) # hide\nnothing # hide","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"plot((sin, cos, x -> x), 0, 4pi)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"(The use of tuples to pair functions is idiosyncratic; the Plots.jl style of passing functions for the first 3 (or 2) positional arguments is also supported.)","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"As with 2-dimensional lines, the arguments linecolor, linewidth, linestyle, and lineshape from Plots are available.","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"Using a single function returning a point may be more natural for some usages. Below we use BinderPlots.unzip to take a container of points into 3 containers for the coordinates, x, y, z to pass to plot(x,y,z) (this could also be just plot(r.(ts)). but that interface is not available in Plots.jl):","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"r(t) = (sin(t), cos(t), t)\nrp(t) = (cos(t), -sin(t), 1)\n\nts = range(0, 4pi, length=251)\nplot(BinderPlots.unzip(r.(ts))...; legend=false)\nts = range(0, 4pi, length=10)\nBinderPlots.arrow!(r.(ts), rp.(ts))\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"In the above we used arrow!, with a collection of tails and vectors, to indicate the tangent direction. The arrow! function hacks together an arrow, as there is no underlying 3-dimensional arrow in Plotly.","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"note: arrow!\nThe cones used for the arrow heads are not always scaled properly.","category":"page"},{"location":"three-d-graphics/#Visualizing-f:R2-\\rightarrow-R","page":"3D graphics","title":"Visualizing fR^2 rightarrow R","text":"","category":"section"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"Functions of the two variables which return a single, scalar value can be visualized in different ways. Using 3 dimensions one can use the x-y plane to denote the inputs and the z axis the value forming a surface. In 2 dimensions the value can be represented a few ways: using colors, as with heatmaps, or using a line to show (xy) values with the same z value, as with contour maps.","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"Contour, heatmaps, and surface plots can be produced by contour, heatmap, and surface. Some examples here use the peaks function of MATLAB:","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"function peaks(x,y)\n    z = 3 * (1-x)^2 * exp(-(x^2) - (y+1)^2)\n    z = z - 10 * (x/5 - x^3 - y^5) * exp(-x^2-y^2)\n    z = z - 1/3 * exp(-(x+1)^2 - y^2)\nend","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"A contour graph can be made by specifying a grid of points through a selection of x and y values (utilizing range, as below, is one such way) and the function (of two variables) in a direct manner:","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"xs = range(-3, 3, length=100)\nys = range(-2, 2, length=100)\ncontour(xs, ys, peaks)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"three-d-graphics/#Contour-graphs","page":"3D graphics","title":"Contour graphs","text":"","category":"section"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"The contour lines are automatically selected. Passing a range to the levels argument allows a user choice. Contour plots can be filled with colors. Passing fill=true is all it takes (or calling with contourf):","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"contour(xs, ys, peaks; levels=-3:3, fill=true, colorscale=\"Picnic\")\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"The levels argument can be a range (something with a step method, like -3:3) or a single number.","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"The linewidth argument can adjust the width of the contour lines. The contour_labels argument indicates if the contours should be labeled. The colorbar argument indicates if the colorbar scale should be drawn. (The Plotly counterpoint is showscale.)","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"The Plots.jl argument fill is used to indicate if the space between the contours should be colored to give more indication of the gradient.","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"The Plotly argument colorscale can be one several scales including \"YlOrRd\", \"YlGnBu\", \"RdBu\", \"Portland\", \"Picnic\", \"Jet\", \"Hot\", \"Greys\", \"Greens\", \"Bluered\", \"Electric\", \"Earth\", \"Blackbody\", \"Viridis\", and \"Cividis\".","category":"page"},{"location":"three-d-graphics/#Heatmaps","page":"3D graphics","title":"Heatmaps","text":"","category":"section"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"A heatmap uses color variation, not contour lines, to indicate the differences in z values. As with contour, the colorscale argument is passed to Plotly:","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"heatmap(xs, ys, peaks; colorscale=\"Hot\")\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"three-d-graphics/#Implicitly-defined-functions","page":"3D graphics","title":"Implicitly defined functions","text":"","category":"section"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"The equation f(xy) = 0 for a fixed x may have many y values for a solution. However, locally for most points and nice functions f there is an implicitly defined function y(x). This is useful, say if a tangent line is sought. The plot_implicit function can be used to show implicitly defined function given by f(xy)=0. It is basically a contour plot with only a 0 level.","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"The implementation only asks for a range of x and y values to search over. It chooses the number of intermediate points. The ranges are specified through the arguments xlims and ylims with defaults yielding the region -55 times -55.","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"For example:","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"plot_implicit(peaks; xlims=(-3,3), ylims=(-3,3))\n\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"three-d-graphics/#Surface-plots","page":"3D graphics","title":"Surface plots","text":"","category":"section"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"By surface plot we mean a representation of a 2 dimensional structure within 3 dimensions, as can be visualised.","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"There are two primary ways of generating these:","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"A bivariate, scalar function f R^2 rightarrow R can be visualized with the x-y plane showing the inputs and the z axis the values.\nA parametric description with some function F(uv) = langle X(uv) Y(uv) Z(uv) rangle.","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"We illustrate each:","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"The peaks function can be viewed as easily as the following using surface, where like contour, the xs and ys show where on the x and y axis to sample:","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"xs = range(-3, 3, length=100)\nys = range(-2, 2, length=100)\n\nsurface(xs, ys, peaks)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"Attributes are easily adjusted:","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"surface(xs, ys, peaks; zcontour=true, showscale=false)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"Parametric surfaces can be produced as follows, where, in this usage, BinderPlots.unzip creates 3 matrices to pass to surface:","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"r1, r2 = 2, 1/2\nr(u,v) = ((r1 + r2*cos(v))*cos(u), (r1 + r2*cos(v))*sin(u), r2*sin(v))\nus = vs = range(0, 2pi, length=25)\n\np = surface(BinderPlots.unzip(us, vs, r)...;\n\taspect_ratio=:equal, showscale=false)\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"There isn't much support for arguments from the Plots.jl implementation, save:","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"aspect_ratio = :equal sets the underlying aspect ratio to be equal.","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"Many Plotly arguments are quite useful:","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"zcontour=true will add a contour graph showing the levels\nopacity makes it easy to set the transparency of the rendered object\neye, center, and up can adjust the camera positioning.\nshowscale=false can be specified to avoid the drawing of a color scale.","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"This last example shows how to plot a surface and two planes along with their intersections with the surface emphasized. The latter uses the Contours package. One plane has the form ax + by + cz = d which for non-zero c has z(x,y) solvable and is visualized through surface. The intersection of the surface and the plane is the 0-level contour of the function f(xy) - z(xy).","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"The other plane has c=0, so is plotted differently. That plane is described as lying in the direction of the vectors ab0 and 001 and going through the point x_0 y_0 0. This gives b(x-x_0) - a(y-y_0) = 0. We plot this parametrically. The intersecion can be found by projecting the line in the x-y plane onto the surface.","category":"page"},{"location":"three-d-graphics/","page":"3D graphics","title":"3D graphics","text":"f(x, y) = 4 - x^2 - y^2\n\nxs = ys = range(-2, 2, length=100)\nsurface(xs, ys, f; legend=false, showscale=false)\n\n# plane of the from a*x + b*y + c*z = d, c != 0\na,b,c,d = 1,1,1,2.5\nz(x,y) = (d - a*x - b*y) / c\nsurface!(xs, ys, z, opacity=0.25, showscale=false)\n\n# One way to plot intersection numerically\nimport Contour\ncs = Contour.contours(xs, ys, ((x,y) -> f(x,y) - z(x,y)).(xs', ys), [0])\nfor cl ∈ Contour.levels(cs)\n    for line in Contour.lines(cl)\n        xₛ, yₛ = Contour.coordinates(line) # coordinates of this line segment\n        plot!(xₛ, yₛ, z.(xₛ, yₛ), linecolor=\"black\", linewidth=10)\n    end\nend\n\n# plane parallel to [a,b,0], [0,0,1] and through [x0,y0,0]\na,b = 1, 1\nx0, y0 = 0, 0 # origin\n\nzs = range(-4, 4, length=100) # or extrema(z.(xs', ys))\nXs = ((x,z) -> x).(xs', zs)\nZs = ((x,z) -> z).(xs', zs)\n\nc, d = 0, b*x0 - a * y0\nplane(x,z) = (d + a*x - c*z) / b\nYs = plane.(xs', zs)\nsurface!(Xs, Ys, Zs, opacity=0.25, showscale=false)\n\ng(t) = (b*t -d)/a # line in x-y plane\nxxs = xs\nyys = g.(xxs)\nzzs = f.(xxs, yys)\nplot!(xxs, yys, zzs, linewidth=10, linecolor=\"black\")\n\ndelete!(current().layout, :width)  # hide\ndelete!(current().layout, :height) # hide\nto_documenter(current())           # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = BinderPlots","category":"page"},{"location":"#BinderPlots","page":"Home","title":"BinderPlots","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for BinderPlots, a simple plotting package for resource-constrained environments using PlotlyLight.jl to render graphics described with an interface borrowed from Plots.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Plotly is a JavaScript library for plotting that is widely used and has supported interfaces for Python, R, and Julia (through PlotlyJS).\nPlotlyLight is a very lightweight package to create Plotly graphs using the JavaScript interface. The JSON structures are readily created using the clever Config constructor on the Julia side.\nPlots.jl is a popular package for plotting in Julia with numerous backends including Plotly.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides a light-weight plotting alternative to Plots.jl utilizing a subset of the Plots interface, particularly where it allows a function to be specified in a declarative manner. It is inspired by SimplePlots and is envisioned as being useful within resource-constrained environments such as binder.org.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is not a re-implementation of Plots. That package is far more developed in terms of its API, its extendable plot recipes, and its extensions like StatsPlots.jl. This package only provides a small fraction, primarily that part of the interface that makes visualizing functions in low dimensions easier.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is not registered. It may be installed through Pkg.add(url=\"...\")).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once installed, the package is loaded in the standard manner.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BinderPlots\nusing PlotlyDocumenter # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package should load very quickly and the time to first plot should be quite speedy as this is the case for PlotlyLight.","category":"page"},{"location":"#Saving-figures","page":"Home","title":"Saving figures","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Saving figures is the same as with PlotlyLight.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To save a figure to HTML, we have:","category":"page"},{"location":"","page":"Home","title":"Home","text":"BinderPlots.PlotlyLight.save(p, \"filename.html\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To save a figure to an image file, the PlotlyKaleido package is used:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PlotlyKaleido\nPlotlyKaleido.start()\n\n(;data, layout, config) = p;\nPlotlyKaleido.savefig((; data, layout, config), \"myplot.png\")","category":"page"}]
}
